:PROPERTIES:
:header-args:emacs-lisp: :results none :exports code
:END:

#+title: Config

* Rudimentary configuration
** Confpkg
Clump parts of config into "self-contained packets of functionality"
*** Design
It's already natural to organize blocks of config under sections, and we can use =:noweb-ref= with a =header-args:emacs-lisp= property to direct all child source blocks into a single parent. We could have two parents, one tangling to =subconf/config-X.el= and the other to =config.el=, however this will duplicate any evaluations required to generate the content, which isn't great (particularly for things which take a moment, like checking for LaTeX packages). Instead we can /just/ write to the =subconf/*= files and then at the end of tangling extract their contents into =config.el=.

To set this up within each section, instead of manually repeating a common form we can generate the form and supply the relevant section properties via a babel call keyword, like so:
#+begin_src org
,* Subject

,#+call: confpkg("subject")

,#+begin_src emacs-lisp
;; Code that configures the subject...
,#+end_src
#+end_src
*** Preparation
This approach is built around =#+call= invocations that affect the tangling. Unfortunately for this use-case, babel call keywords are not executed on tangle. However, a *noweb ref* can be executed on tangle if we choose to expand its evaluation result instead of its body. And so we can fudge the behaviour we want by tangling a noweb ref to a temp file, where the referenced block(=confpkg-prepare=) executes all babel calls in the buffer.
#+name: confpkg-prepare
#+begin_src emacs-lisp :noweb no-export
(condition-case nil
    (progn
      (message "Intitialising confpkg")
      (org-fold-core-ignore-fragility-checks
        (org-babel-map-executables nil
          (when (eq (org-element-type (org-element-context)) 'babel-call)
            (org-babel-lob-execute-maybe)))))
  (quit (revert-buffer t t t)))
#+end_src

And here's the tangled noweb-ref that will execute =confpk-prepare=.
#+header: :tangle (expand-file-name (make-temp-name "emacs-org-babel-excuses/confpkg-prepare-") temporary-file-directory)
#+begin_src emacs-lisp :noweb no-export :mkdirp yes :export-embed no
<<confpkg-prepare()>>
#+end_src

*** Setup
Before generating the template with babel, we want to keep track of:
+ How many config groups are created
+ Information about each config group

To do this we can simply create two variables. Due to temp-buffer shenanigans,
we'll have to use global variables here.

Then we need to set up the two final phases of this process:
+ Creating =config.el=
+ Cleaning up the superfluous generated content

To trigger the final phases we'll add a hook to ~org-babel-post-tangle-hook~. Once
again, it would be preferred if this was done locally, but it needs to be
global. To avoid this causing headaches down the line we'll make sure when
implementing the hook function to have it remove itself from the hook when
executed.
#+name: confpkg-setup
#+begin_src emacs-lisp :results silent :noweb no-export
(setq confpkg--num 0
      confpkg--list nil)

;; provide functions to be used in confpkg-tangle-finalize
<<confpkg-dependency-analysis>>
<<confpkg-strip-package-statements>>
<<confpkg-create-config>>
(defun confpkg-cleanup ()
 <<confpkg-cleanup>>
  )
<<confpkg-finalizer>>

;; executed right away and not just a function definition
<<confpkg-clear-old-files>>

(add-hook 'org-babel-tangle-finished-hook #'confpkg-tangle-finalize)
#+end_src

To avoid generating cruft, it would also be good to get rid of old tangled
config files at the start.
#+name: confpkg-clear-old-files
#+begin_src emacs-lisp
(make-directory "subconf" t)
(dolist (conf-file (directory-files "subconf" t "config-.*\\.el"))
  (delete-file conf-file))
#+end_src

Now to have this take effect, we can just use a babel call keyword. Thanks to
the preparation step this will be executed during tangling.
#+call: confpkg-setup[:results none]()

*** Package generation
Now we actually implement the =confpkg= babel function. We could just direct the
output into the =subconf/config-X.el= file without any extra steps, but why not be
a bit fancier and make it more like a package.

To do this, we'll have =confpkg= load a template and then fill it in using
~format-spec~. To make sure this is actually used, we'll call ~org-set-property~ to
modify the parent heading, and register the config group with the variables we
created earlier.
#+name: confpkg
#+begin_src elisp :var name="" needs="" after="" pre="" prefix="config-" via="copy" emacs-minimum="29.1" :results raw :noweb no-export
;; Babel block for use with #+call
;; Arguments:
;;  - name, the name of the config sub-package
;;  - needs, (when non-empty) required system executable(s)
;;  - after, required features as a string or vector of strings
;;  - pre, a noweb reference to code that should be executed eagerly,
;;    and not deferred via after. The code is not included in the
;;    generated .el file and should only be used in dire situations.
;;  - prefix, the package prefix ("config-" by default)
;;  - via, how this configuration should be included in config.el,
;;    the current options are:
;;    + "copy", copy the configuration lisp
;;    + "require", insert a require statement
;;    + "none", do not do anything to load this configuration.
;;      This only makes sense when configuration is either being
;;      temporarily disabled or loaded indirectly/elsewhere.
;;  - emacs-minimum, the minimum emacs version ("29.1" by default)
(when (or (string-empty-p needs)
          (cl-every #'executable-find (delq nil (split-string needs ","))))
  (let* ((name (if (string-empty-p name)
                   (save-excursion
                     (and (org-back-to-heading-or-point-min t)
                          (substring-no-properties
                           (org-element-interpret-data
                            (org-element-property :title (org-element-at-point))))))
                 name))
         (after
          (cond
           ((and (stringp after) (string-empty-p after)) nil)
           ((and (stringp after) (string-match-p "\\`[^()]+\\'" after))
            (intern after)) ; Single feature.
           ((and (vectorp after) (cl-every #'stringp after))
            (nconc (list :and) (mapcar #'intern after)))
           (t nil)))
         (pre (and (not (string-empty-p pre)) pre))
         (confpkg-name
          (concat prefix (replace-regexp-in-string
                          "[^a-z-]" "-" (downcase name))))
         (confpkg-file (expand-file-name (concat confpkg-name ".el")
                                         "subconf")))
    (unless (file-exists-p confpkg-file)
      (make-empty-file confpkg-file t))
    (cl-incf confpkg--num)
    (org-set-property
     "header-args:emacs-lisp"
     (format ":tangle no :noweb-ref %s :noweb-sep \"\\n\\n\"" confpkg-name))
    (push (list :name name
                :package confpkg-name
                :file confpkg-file
                :after after
                :pre pre
                :via (intern via)
                :package-statements nil)
          confpkg--list)
    (format-spec
     "#+begin_src emacs-lisp :tangle %f :mkdirp yes :noweb no-export :noweb-ref none :comments no
<<confpkg-template>>
,#+end_src"
     `((?n . ,confpkg--num)
       (?p . ,confpkg-name)
       (?f . ,confpkg-file)
       (?e . ,emacs-minimum)
       (?Y . ,(format-time-string "%Y"))
       (?B . ,(format-time-string "%B"))
       (?m . ,(format-time-string "%m"))
       (?d . ,(format-time-string "%d"))
       (?M . ,(format-time-string "%M"))
       (?S . ,(format-time-string "%S"))))))
#+end_src

Now all that's needed is a template to be used.
#+name: confpkg-template
#+begin_src emacs-lisp :eval no
;;; %p.el --- Generated package (no.%n) from my config -*- lexical-binding: t; -*-
;;
;; Author: aesbetic
;; Maintainer: aesbetic
;; Created: %B %d, %Y
;; Modified: %B %d, %Y
;; Version: %Y.%m.%d
;; Homepage: https://github.com/ekattsim
;; Package-Requires: ((emacs \"%e\"))
;;
;; This file is not part of GNU Emacs.
;;
;;; Commentary:
;;
;;  Generated package (no.%n) from my config.
;;
;;  During generation, dependency on other aspects of my configuration and
;;  packages is inferred via (regexp-based) static analysis.  While this seems
;;  to do a good job, this method is imperfect.  This code likely depends on
;;  utilities provided by Doom, and if you try to run it in isolation you may
;;  discover the code makes more assumptions.
;;
;;  That said, I've found pretty good results so far.
;;
;;; Code:

<<%p>>

(provide '%p)
;;; %p.el ends here
#+end_src

This currently makes the included content look much more package-like than it
truly is.

Lastly, should there be an issue or interruption, it's possible that the
modifications from =#+call: confpkg= may persist. If I've been good with my
committing, resolving this should be as simple as reverting unstaged changes.
So... back in reality, it would be nice to have a way to clean up =confpkg=
residue.
#+name: confpkg-cleanup
#+begin_src emacs-lisp :results none
(org-fold-core-ignore-fragility-checks
  (org-babel-map-executables nil
    (when (and (eq (org-element-type (org-element-context)) 'babel-call)
               (equal (org-element-property :call (org-element-context)) "confpkg"))
      (org-babel-remove-result)
      (org-entry-delete nil "header-args:emacs-lisp"))))
#+end_src

*** Identify cross-package dependencies
:PROPERTIES:
:header-args:emacs-lisp: :noweb-ref confpkg-dependency-analysis
:END:

At a basic level, we can search for regexp expressions indicating the definition
of functions or variables and search for their usage.

#+begin_src emacs-lisp
(defun confpkg--rough-extract-definitions (file)
  (with-temp-buffer
    (insert-file-contents file)
    (goto-char (point-min))
    (let (symbols)
      (while (re-search-forward
              (rx line-start (* (any ?\s ?\t)) "("
                  (or "defun" "defmacro" "defsubst" "defgeneric" "defalias" "defvar" "defcustom" "defface" "deftheme"
                      "cl-defun" "cl-defmacro" "cl-defsubst" "cl-defmethod" "cl-defstruct" "cl-defgeneric" "cl-deftype")
                  (+ (any ?\s ?\t))
                  (group (+ (any "A-Z" "a-z" "0-9"
                                 ?+ ?- ?* ?/ ?_ ?~ ?! ?@ ?$ ?% ?^ ?& ?= ?: ?< ?> ?{ ?})))
                  (or blank ?\n))
              nil t)
        (push (match-string 1) symbols))
      symbols)))
#+end_src

Continuing our rough regexp approach, we can construct a similar function to
look for uses of symbols.

#+begin_src emacs-lisp
(defun confpkg--rough-uses-p (file symbols)
  (with-temp-buffer
    (insert-file-contents file)
    (let ((symbols (copy-sequence symbols)) uses-p)
      (while symbols
        (goto-char (point-min))
        (if (re-search-forward (rx word-start (literal (car symbols)) word-end) nil t)
            (setq uses-p t symbols nil)
          (setq symbols (cdr symbols))))
      uses-p)))
#+end_src

Now we can put these two functions together to annotate ~confpkg--list~ with their
(confpkg) dependencies.

#+begin_src emacs-lisp
(defun confpkg-annotate-list-dependencies ()
  (dolist (confpkg confpkg--list)
    (plist-put confpkg :defines
               (confpkg--rough-extract-definitions
                (plist-get confpkg :file))))
  (dolist (confpkg confpkg--list)
    (let ((after (plist-get confpkg :after))
          requires)
      (dolist (other-confpkg confpkg--list)
        (when (and (not (eq other-confpkg confpkg))
                   (confpkg--rough-uses-p (plist-get confpkg :file)
                                          (plist-get other-confpkg :defines)))
          (push (plist-get other-confpkg :package) requires)))
      (when (and after (symbolp after))
        (push after requires))
      (plist-put confpkg :requires requires))))
#+end_src

Finally, we can use this information to edit the confpkg files to add the
necessary ~require~ statements.

#+begin_src emacs-lisp
(defun confpkg-write-dependencies ()
  (dolist (confpkg confpkg--list)
    (when (plist-get confpkg :requires)
      (with-temp-buffer
        (setq buffer-file-name (plist-get confpkg :file))
        (insert-file-contents buffer-file-name)
        (re-search-forward "^;;; Code:\n")
        (insert "\n")
        (dolist (req (plist-get confpkg :requires))
          (insert (format "(require '%s)\n" req)))
        (write-region nil nil buffer-file-name)
        (set-buffer-modified-p nil)))))
#+end_src

*** Commenting out ~package!~ statements

It's easy enough to set ~package!~ statements to tangle to =packages.el=, however
with our noweb ref approach they will /also/ go to the config files. This could be
viewed as a problem, but I actually think it's rather nice to have the package
information with the config. So, we can look for an immediate ~package!~ statement
and simply comment it out. As a bonus, we can also then record which packages
are needed for each block of config.

#+name: confpkg-strip-package-statements
#+begin_src emacs-lisp
(defun confpkg-comment-out-package-statements ()
  (dolist (confpkg confpkg--list)
    (with-temp-buffer
      (setq buffer-file-name (plist-get confpkg :file))
      (insert-file-contents buffer-file-name)
      (goto-char (point-min))
      (while (re-search-forward "^;;; Code:\n[[:space:]\n]*(\\(package!\\|unpin!\\)[[:space:]\n]+\\([^[:space:]]+\\)\\b" nil t)
        (plist-put confpkg :package-statements
                   (nconc (plist-get confpkg :package-statements)
                          (list (match-string 2))))
        (let* ((start (progn (beginning-of-line) (point)))
               (end (progn (forward-sexp 1)
                           (if (looking-at "[\t ]*;.*")
                               (line-end-position)
                             (point))))
               (contents (buffer-substring start end))
               paste-start paste-end
               (comment-start ";")
               (comment-padding "   ")
               (comment-end ""))
          (delete-region start (1+ end))
          (re-search-backward "^;;; Code:")
          (beginning-of-line)
          (insert ";;  Package statement:\n")
          (setq paste-start (point))
          (insert contents)
          (setq paste-end (point))
          (insert  "\n;;\n")
          (comment-region paste-start paste-end 2)))
      (when (buffer-modified-p)
        (write-region nil nil buffer-file-name)
        (set-buffer-modified-p nil)))))
#+end_src

*** Creating the config file

After all the subconfig files have been tangled, we need to collect their
content and put them together into =config.el=. For this, all that's needed is a
function to go through the registered config groups and put their content in a
tempbuffer. We can call this with the finalising step.

#+name: confpkg-create-config
#+begin_src emacs-lisp
(defun confpkg-create-config ()
  (let ((revert-without-query '("config\\.el"))
        (original-buffer (current-buffer)))
    (with-temp-buffer
      (insert
       (format ";;; config.el -*- lexical-binding: t; -*-

;; Generated at %s from the literate configuration.

(add-to-list 'load-path %S)\n"
               (format-time-string "%FT%T%z")
               (replace-regexp-in-string
                (regexp-quote (getenv "HOME")) "~"
                (expand-file-name "subconf/"))))
      (mapc
       (lambda (confpkg)
         (insert
          (if (eq 'none (plist-get confpkg :via))
              (format "\n;;; %s intentionally omitted.\n" (plist-get confpkg :name))
            (with-temp-buffer
              (cond
               ((eq 'copy (plist-get confpkg :via))
                (insert-file-contents (plist-get confpkg :file))
                (goto-char (point-min))
                (narrow-to-region
                 (re-search-forward "^;;; Code:\n+")
                 (progn
                   (goto-char (point-max))
                   (re-search-backward (format "[^\n\t ][\n\t ]*\n[\t ]*(provide '%s)" (plist-get confpkg :package)))
                   (match-end 0))))
               ((eq 'require (plist-get confpkg :via))
                (insert (format "(require '%s)\n" (plist-get confpkg :package))))
               (t (insert (format "(warn \"%s confpkg :via has unrecognised value: %S\" %S %S)"
                                  (plist-get confpkg :name) (plist-get confpkg :via)))))
              (goto-char (point-min))
              (insert "\n;;:------------------------"
                      "\n;;; " (plist-get confpkg :name)
                      "\n;;:------------------------\n\n")
              (when (plist-get confpkg :defines)
                (insert ";; This block defines "
                        (mapconcat
                         (lambda (d) (format "`%s'" d))
                         (plist-get confpkg :defines)
                         ", ")
                        ".")
                (when (re-search-backward "\\([^, ]+\\), \\([^, ]+\\), \\([^, ]+\\).\\="
                                          (line-beginning-position) t)
                  (replace-match "\\1, \\2, and \\3."))
                (when (re-search-backward "\\([^, ]+\\), \\([^, ]+\\).\\="
                                          (line-beginning-position) t)
                  (replace-match "\\1 and \\2."))
                (insert "\n\n")
                (forward-line -2)
                (setq-local comment-start ";")
                (fill-comment-paragraph)
                (forward-paragraph 1)
                (forward-line 1))
              (if (equal (plist-get confpkg :package) "config-confpkg-timings")
                  (progn
                    (goto-char (point-max))
                    (insert "\n\n\
(confpkg-create-record 'doom-pre-config (float-time (time-subtract (current-time) before-init-time)))
(confpkg-start-record 'config)
(confpkg-create-record 'config-defered 0.0 'config)
(confpkg-create-record 'set-hooks 0.0 'config-defered)
(confpkg-create-record 'load-hooks 0.0 'config-defered)
(confpkg-create-record 'requires 0.0 'root)\n"))
                (let ((after (plist-get confpkg :after))
                      (pre (and (plist-get confpkg :pre)
                                (org-babel-expand-noweb-references
                                 (list "emacs-lisp"
                                       (format "<<%s>>" (plist-get confpkg :pre))
                                       '((:noweb . "yes")
                                         (:comments . "none")))
                                 original-buffer)))
                      (name (replace-regexp-in-string
                             "config--?" ""
                             (plist-get confpkg :package))))
                  (if after
                      (insert (format "(confpkg-with-record '%S\n"
                                      (list (concat "hook: " name) 'set-hooks))
                              (if pre
                                  (concat ";; Begin pre\n" pre "\n;; End pre\n")
                                "")
                              (format (if (symbolp after) ; If single feature.
                                          "  (with-eval-after-load '%s\n"
                                        "  (after! %s\n")
                                      after))
                    (when pre
                      (insert "\n;; Begin pre (unnecesary since after is unused)\n"
                              pre
                              "\n;; End pre\n")))
                  (insert
                   (format "(confpkg-with-record '%S\n"
                           (list (concat "load: " name)
                                 (if after 'load-hooks 'config)))))
                (goto-char (point-max))
                (when (string-match-p ";" (thing-at-point 'line))
                  (insert "\n"))
                (insert ")")
                (when (plist-get confpkg :after)
                  (insert "))"))
                (insert "\n"))
              (buffer-string)))))
       (let ((confpkg-timings ;; Ensure timings is put first.
              (cl-some (lambda (p) (and (equal (plist-get p :package) "config-confpkg-timings") p))
                       confpkg--list)))
         (append (list confpkg-timings)
                 (nreverse (remove confpkg-timings confpkg--list)))))
      (insert "\n(confpkg-finish-record 'config)\n\n;;; config.el ends here")
      (write-region nil nil "config.el" nil :silent))))
#+end_src

Applying lexical binding to the config file is good for a number of reasons,
among which it's (slightly) faster than dynamic binding (see [[https://nullprogram.com/blog/2016/12/22/][this blog post]] for
more info).

*** Quieter output

All the babel evaluation here ends up being quite noisy (along with a few other
things during tangle), let's see if we can change that.

#+name: confpkg-quieter-output
#+begin_src emacs-lisp
(when noninteractive
  (unless (fboundp 'doom-shut-up-a)
    (defun doom-shut-up-a (fn &rest args)
      (let ((standard-output #'ignore)
            (inhibit-message t))
        (apply fn args))))
  (advice-add 'org-babel-expand-body:emacs-lisp :around #'doom-shut-up-a)
  ;; Quiet some other annoying messages
  (advice-add 'sh-set-shell :around #'doom-shut-up-a)
  (advice-add 'rng-what-schema :around #'doom-shut-up-a)
  (advice-add 'python-indent-guess-indent-offset :around #'doom-shut-up-a))
#+end_src

#+call: confpkg-quieter-output()

*** Reporting load time information

#+call: confpkg("Confpkg timings")

When generating the config we added a form to collect load-time information.

#+begin_src emacs-lisp
(defvar confpkg-load-time-tree (list (list 'root)))
(defvar confpkg-record-branch (list 'root))
(defvar confpkg-record-num 0)
#+end_src

It would be good to process ~confpkg-load-times~ at the end to make it more
useful, and provide a function to display load time information from it. This is
to aid in identification of confpkgs that take particularly long to load, and
thus would benefit from some attention.

To extract the per-confpkg load times, we can just take the difference in
~(float-time)~ and exclude the first entry.

#+begin_src emacs-lisp
(defun confpkg-create-record (name elapsed &optional parent enclosing)
  (let ((parent (assoc (or parent (car confpkg-record-branch))
                       confpkg-load-time-tree))
        (record (cons name (list (list 'self
                                       :name (format "%s" name)
                                       :num (cl-incf confpkg-record-num)
                                       :elapsed elapsed
                                       :enclosing enclosing)))))
    (push record confpkg-load-time-tree)
    (push record (cdr parent))
    record))

(defun confpkg-start-record (name &optional parent)
  (let ((record (confpkg-create-record name 0.0e+NaN parent t)))
    (plist-put (cdadr record) :start (float-time))
    (push name confpkg-record-branch)
    record))

(defun confpkg-finish-record (name)
  (let ((self-record (cdar (last (cdr (assoc name confpkg-load-time-tree))))))
    (plist-put self-record :elapsed
               (- (float-time) (plist-get self-record :start) 0.0))
    (unless (equal (car confpkg-record-branch) name)
      (message "Warning: Confpkg timing record expected to finish %S, instead found %S. %S"
               name (car confpkg-record-branch) confpkg-record-branch))
    (setq confpkg-record-branch (cdr confpkg-record-branch))))
#+end_src

A convenience macro could be nice to have.

#+begin_src emacs-lisp
(defmacro confpkg-with-record (name &rest body)
  "Create a time record around BODY.
The record must have a NAME."
  (declare (indent 1))
  (let ((name-val (make-symbol "name-val"))
        (record-spec (make-symbol "record-spec")))
    `(let* ((,name-val ,name)
            (,record-spec (if (consp ,name-val) ,name-val (list ,name-val))))
       (apply #'confpkg-start-record ,record-spec)
       (unwind-protect
           (progn ,@body)
         (confpkg-finish-record (car ,record-spec))))))
#+end_src

It would also be nice to collect some other load-time-related information.

#+begin_src emacs-lisp
(defadvice! +require--log-timing-a (orig-fn feature &optional filename noerror)
  :around #'require
  (if (or (featurep feature)
          (eq feature 'cus-start) ; HACK Why!?!
          (assoc (format "require: %s" feature) confpkg-load-time-tree))
      (funcall orig-fn feature filename noerror)
    (confpkg-with-record (list (format "require: %s" feature)
                               (and (eq (car confpkg-record-branch) 'root)
                                    'requires))
      (funcall orig-fn feature filename noerror))))
#+end_src

At last, we'll go to some pains to make a nice result tabulation function.

I will readily admit that this function is absolutely horrible. I just spent an
evening adding to it till it worked then stopped touching it. Maybe in the
future I'll go back to it and try to clean up the implementation.

#+begin_src emacs-lisp
(defun confpkg-timings-report (&optional sort-p node)
  "Display a report on load-time information.
Supply SORT-P (or the universal argument) to sort the results.
NODE defaults to the root node."
  (interactive
   (list (and current-prefix-arg t)))
  (let ((buf (get-buffer-create "*Confpkg Load Time Report*"))
        (depth 0)
        num-pad name-pad max-time max-total-time max-depth)
    (cl-labels
        ((sort-records-by-time
          (record)
          (let ((self (assoc 'self record)))
            (append (list self)
                    (sort (nreverse (remove self (cdr record)))
                          (lambda (a b)
                            (> (or (plist-get (alist-get 'self a) :total) 0.0)
                               (or (plist-get (alist-get 'self b) :total) 0.0)))))))
         (print-record
          (record)
          (cond
           ((eq (car record) 'self)
            (insert
             (propertize
              (string-pad (number-to-string (plist-get (cdr record) :num)) num-pad)
              'face 'font-lock-keyword-face)
             " "
             (propertize
              (apply #'concat
                     (make-list (1- depth) "• "))
              'face 'font-lock-comment-face)
             (string-pad (format "%s" (plist-get (cdr record) :name)) name-pad)
             (make-string (* (- max-depth depth) 2) ?\s)
             (propertize
              (format "%.4fs" (plist-get (cdr record) :elapsed))
              'face
              (list :foreground
                    (doom-blend 'orange 'green
                                (/ (plist-get (cdr record) :elapsed) max-time))))
             (if (= (plist-get (cdr record) :elapsed)
                    (plist-get (cdr record) :total))
                 ""
               (concat "   (Σ="
                       (propertize
                        (format "%.3fs" (plist-get (cdr record) :total))
                        'face
                        (list :foreground
                              (doom-blend 'orange 'green
                                          (/ (plist-get (cdr record) :total) max-total-time))))
                       ")"))
             "\n"))
           (t
            (cl-incf depth)
            (mapc
             #'print-record
             (if sort-p
                 (sort-records-by-time record)
               (reverse (cdr record))))
            (cl-decf depth))))
         (flatten-records
          (records)
          (if (eq (car records) 'self)
              (list records)
            (mapcan
             #'flatten-records
             (reverse (cdr records)))))
         (tree-depth
          (records &optional depth)
          (if (eq (car records) 'self)
              (or depth 0)
            (1+ (cl-reduce #'max (cdr records) :key #'tree-depth))))
         (mapreduceprop
          (list map reduce prop)
          (cl-reduce
           reduce list
           :key
           (lambda (p) (funcall map (plist-get (cdr p) prop)))))
         (elaborate-timings
          (record)
          (if (eq (car record) 'self)
              (plist-get (cdr record) :elapsed)
            (let ((total (cl-reduce #'+ (cdr record)
                                    :key #'elaborate-timings))
                  (self (cdr (assoc 'self record))))
              (if (plist-get self :enclosing)
                  (prog1
                      (plist-get self :elapsed)
                    (plist-put self :total (plist-get self :elapsed))
                    (plist-put self :elapsed
                               (- (* 2 (plist-get self :elapsed)) total)))
                (plist-put self :total total)
                total))))
         (elaborated-timings
          (record)
          (let ((record (copy-tree record)))
            (elaborate-timings record)
            record)))
      (let* ((tree
              (elaborated-timings
               (append '(root)
                       (copy-tree
                        (alist-get (or node 'root)
                                   confpkg-load-time-tree
                                   nil nil #'equal))
                       '((self :num 0 :elapsed 0)))))
             (flat-records
              (cl-remove-if
               (lambda (rec) (= (plist-get (cdr rec) :num) 0))
               (flatten-records tree))))
        (setq max-time (mapreduceprop flat-records #'identity #'max :elapsed)
              max-total-time (mapreduceprop flat-records #'identity #'max :total)
              name-pad (mapreduceprop flat-records #'length #'max :name)
              num-pad (mapreduceprop flat-records
                                     (lambda (n) (length (number-to-string n)))
                                     #'max :num)
              max-depth (tree-depth tree))
        (with-current-buffer buf
          (erase-buffer)
          (setq-local outline-regexp "[0-9]+ *\\(?:• \\)*")
          (outline-minor-mode 1)
          (use-local-map (make-sparse-keymap))
          (local-set-key "TAB" #'outline-toggle-children)
          (local-set-key "\t" #'outline-toggle-children)
          (local-set-key (kbd "<backtab>") #'outline-show-subtree)
          (local-set-key (kbd "C-<iso-lefttab>")
                         (eval `(cmd! (if current-prefix-arg
                                          (outline-show-all)
                                        (outline-hide-sublevels (+ ,num-pad 2))))))
          (insert
           (propertize
            (concat (string-pad "#" num-pad) " "
                    (string-pad "Confpkg"
                                (+ name-pad (* 2 max-depth) -3))
                    (format " Load Time (Σ=%.3fs)\n"
                            (plist-get (cdr (assoc 'self tree)) :total)))
            'face '(:inherit (tab-bar-tab bold) :extend t :underline t)))
          (dolist (record (if sort-p
                              (sort-records-by-time tree)
                            (reverse (cdr tree))))
            (unless (eq (car record) 'self)
              (print-record record)))
          (set-buffer-modified-p nil)
          (goto-char (point-min)))
        (pop-to-buffer buf)))))
#+end_src

*** Finalize

At last, to clean up the content inserted by the babel calls we can just revert
the buffer. As long as ~org-babel-pre-tangle-hook~ hasn't been modified,
~save-buffer~ will be run at the start of the tangle process and so reverting will
take us back to just before the tangle started.

Since this is /the/ function added as the post-tangle hook, we also need to remove
the function from the hook and call the =config.el= creation function.

#+name: confpkg-finalizer
#+begin_src emacs-lisp
(defun confpkg-tangle-finalize ()
  (remove-hook 'org-babel-tangle-finished-hook #'confpkg-tangle-finalize)
  (revert-buffer t t t)
  (confpkg-comment-out-package-statements)
  (confpkg-annotate-list-dependencies)
  (confpkg-create-config)
  (confpkg-write-dependencies)
  (message "Processed %s elisp files" (length confpkg--list)))
#+end_src

Within ~confpkg-tangle-finalize~ we carefully order each step so that
the most important steps go first, to minimise the impact should a particular
step fail.
** Personal information
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Aesbetic"
      user-mail-address "aesbetic@gmail.com")
#+END_SRC
** Better defaults
Make changes to the *defaults of core emacs features* here.
*** Simple settings
Small tweaks on top of Doom defaults.
#+BEGIN_SRC emacs-lisp
(setq evil-want-fine-undo t)
#+END_SRC
*** Auto-customizations
Load the custom.el file if it exists.
#+BEGIN_SRC emacs-lisp
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC
*** Frames
Remove the title bar because it's unaesthetic.
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(undecorated-round . t))
#+END_SRC
*** Windows
**** Split prompt
Ask what buffer to switch to after making a new window split because it's a common operation I do.

First make newly-split window the active window
#+BEGIN_SRC emacs-lisp
(setq evil-split-window-below t
      evil-vsplit-window-right t)
#+END_SRC
Then, show a buffer prompt
#+BEGIN_SRC emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+END_SRC
**** Window operations
Window rotation is nice, and can be found under SPC w r and SPC w R. Layout rotation is also nice though. Let's stash this under SPC w SPC, inspired by Tmux's use of C-b SPC to rotate windows.
#+BEGIN_SRC emacs-lisp
(map! :map evil-window-map
      "SPC" #'rotate-layout)
#+END_SRC
      
I find symbolic keybinds to be more intuitive, so let's add them for window split creation.
#+BEGIN_SRC emacs-lisp
(map! :leader
      "-" #'evil-window-split
      "|" #'evil-window-vsplit)
#+END_SRC
*** Buffers
Enable relative line numbers because it's a habit from vim
#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type 'relative)
#+END_SRC

Make working with wrapped lines easy
#+BEGIN_SRC emacs-lisp
(map!  :nv "j" #'evil-next-visual-line
       :nv "k" #'evil-previous-visual-line)
#+END_SRC

General buffer navigation
#+BEGIN_SRC emacs-lisp
(map!  :m "H" #'evil-beginning-of-visual-line
       :m "L" #'evil-end-of-visual-line
       :m "0" #'evil-window-top
       :m "$" #'evil-window-bottom)
#+END_SRC
*** Files
Bind "<leader>ff" to switch to src/header pair replacing the find-file offered by doom. This is okay because "<leader>." does finding files for me.
#+BEGIN_SRC emacs-lisp
(map! :leader :desc "Find other file" "f f" #'ff-find-other-file)
#+END_SRC
* UI
** System
*** TODO Theme: apply rose-pine for the soho vibes :theme:
Load theme, taking current system APPEARANCE into consideration.
#+BEGIN_SRC emacs-lisp
(defun my/apply-theme (appearance)
  (mapc #'disable-theme custom-enabled-themes)
  (pcase appearance
    ('light (load-theme 'tango t))
    ('dark (load-theme 'doom-lantern t))))
(add-hook 'ns-system-appearance-change-functions #'my/apply-theme)
#+END_SRC
*Note:* I might remove this if it gets dark outside too quick.
*** Fonts
Add Roboto Mono and Source Sans Pro as fixed and variable pitch fonts respectively. I'm choosing not to use "doom-font" to keep things migratable.
#+BEGIN_SRC emacs-lisp
(when (member "Roboto Mono" (font-family-list))
  (set-face-attribute 'default nil :family "Roboto Mono" :height 150)
  (set-face-attribute 'fixed-pitch nil :family "Roboto Mono"))

(when (member "Source Sans Pro" (font-family-list))
  ;; variable pitch font will be a little larger than fixed fonts
(set-face-attribute 'variable-pitch nil :family "Source Sans Pro" :height 1.20))
#+END_SRC
* Org
** Aesthetics
*** Fonts
Set Roboto Mono as header font and resize headings.
#+BEGIN_SRC emacs-lisp
;; Resize Org headings
(dolist (face '((org-level-1 . 1.35)
                (org-level-2 . 1.3)
                (org-level-3 . 1.2)
                (org-level-4 . 1.1)
                (org-level-5 . 1.1)
                (org-level-6 . 1.1)
                (org-level-7 . 1.1)
                (org-level-8 . 1.1)))
  (set-face-attribute (car face) nil :family "Roboto Mono" :weight 'bold :height (cdr face)))

;; Make the document title a bit bigger
(set-face-attribute 'org-document-title nil :family "Roboto Mono" :weight 'bold :height 1.8)
#+END_SRC
*** Decluttering
Don't be a litterbug!
#+BEGIN_SRC emacs-lisp
(setq org-adapt-indentation t
      org-hide-leading-stars t
      org-hide-emphasis-markers t  ;; hide markers(bold, italics, etc)
      org-pretty-entities t) ;; allow LaTeX-like syntax to insert special symbols
#+END_SRC
*** Source Blocks
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-edit-src-content-indentation 0)
#+END_SRC
*** Org-Superstar
#+BEGIN_SRC emacs-lisp
(use-package org-superstar
  :hook (org-mode-hook . (lambda () (org-superstar-mode 1)))
  :after org
  :config
  (setq org-superstar-leading-bullet " "
        org-superstar-headline-bullets-list '("●" "○" "◆" "◇" "•" "⚬")
        org-superstar-item-bullet-alist '((42 . "⚬") (43 . "⚬") (45 . "⚬"))
        org-superstar-prettify-item-bullets t)
  #+END_SRC

Plain-list bullets are invisible because they have the org-indent face. We can make them visible by having them inherit the default face.
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'org-list-dt nil :inherit 'default)
)
#+END_SRC
** Roam
Make "~/zettelkasten" the org-roam directory
#+BEGIN_SRC emacs-lisp
(setq org-roam-directory "~/zettelkasten")
#+END_SRC
** Latex Previews
*** Load/Enable
Configure org-latex-preview to be load after org and enable auto-mode which reveals source text under the fragment being pointed to.
#+BEGIN_SRC emacs-lisp
(use-package org-latex-preview
:after org
:hook (org-mode-hook . org-latex-preview-auto-mode)
#+END_SRC

*** Appearance Settings
Basic appearance settings. I've noticed ":scale" doesn't seem to do anything, this could only be for png.
#+BEGIN_SRC emacs-lisp
:config
;; enable latex-previews startup option
(setq org-startup-with-latex-preview t)

;; Increase preview width
(plist-put org-latex-preview-appearance-options
:page-width 1.0)
(plist-put org-latex-preview-appearance-options
:zoom 1.2)

;; enable consistent equation numbering
(setq org-latex-preview-numbered t)
#+END_SRC

*** Latency and Performance
#+BEGIN_SRC emacs-lisp
;; real time previews of latex fagments as you type
(setq org-latex-preview-live t)
(setq org-latex-preview-live-debounce 0.25)  ;; reducing delay before preview

;; png is faster than svg
(setq org-latex-preview-process-default 'dvipng)
)
#+END_SRC

* Keybinds
** Navigation
*** Workspace
Bind workspace navigation to be more like t-smart
#+BEGIN_SRC emacs-lisp
(map! :ni "C-t" #'+workspace/switch-to
      :ni [C-tab] #'+workspace/other)
#+END_SRC
