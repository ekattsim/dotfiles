:PROPERTIES:
:header-args:emacs-lisp: :results none :exports code
:END:

#+title: config
#+SETUPFILE: /Users/abhijeetsurakanti/dotfiles/emacs/dot-config/doom/misc/SETUPFILE.org

* introduction

This is my attempt at a literate configuration of doom emacs. [[*Confpkg]] is shamelessly lifted from [[https://tecosaur.github.io/emacs-config/config.html#doom-configuration][tecosaur's]] literate config.

* meta configuration

** confpkg

Clump parts of config into "self-contained packets of functionality".

*** design

It's already natural to organize blocks of config under sections, and we can use =:noweb-ref= with a =header-args:emacs-lisp= property to direct all child source blocks into a single parent. We could have two parents, one tangling to =subconf/config-X.el= and the other to =config.el=, however this will duplicate any evaluations required to generate the content, which isn't great (particularly for things which take a moment, like checking for LaTeX packages). Instead we can /just/ write to the =subconf/*= files and then at the end of tangling extract their contents into =config.el=.

To set this up within each section, instead of manually repeating a common form we can generate the form and supply the relevant section properties via a babel call keyword, like so:

#+begin_src org
,* Subject

,#+call: confpkg("subject")

,#+begin_src emacs-lisp
;; Code that configures the subject...
,#+end_src
#+end_src

*** preparation

This approach is built around =#+call= invocations that affect the tangling. Unfortunately for this use-case, babel call keywords are not executed on tangle. However, a *noweb ref* can be executed on tangle if we choose to expand its evaluation result instead of its body. And so we can fudge the behaviour we want by tangling a noweb ref to a temp file, where the referenced block(=confpkg-prepare=) executes all babel calls in the buffer.

#+name: confpkg-prepare
#+begin_src emacs-lisp :noweb no-export
(condition-case nil
    (progn
      (message "Intitialising confpkg")
      (org-fold-core-ignore-fragility-checks
        (org-babel-map-executables nil
          (when (eq (org-element-type (org-element-context)) 'babel-call)
            (org-babel-lob-execute-maybe)))))
  (quit (revert-buffer t t t)))
#+end_src

And here's the tangled noweb-ref that will execute =confpk-prepare=.

#+header: :tangle (expand-file-name (make-temp-name "emacs-org-babel-excuses/confpkg-prepare-") temporary-file-directory)
#+begin_src emacs-lisp :noweb no-export :mkdirp yes :export-embed no
<<confpkg-prepare()>>
#+end_src

*** setup

Before generating the template with babel, we want to keep track of:

+ How many config groups are created
+ Information about each config group

To do this we can simply create two variables. Due to temp-buffer shenanigans,
we'll have to use global variables here.

Then we need to set up the two final phases of this process:

+ Creating =config.el=
+ Cleaning up the superfluous generated content

To trigger the final phases we'll add a hook to ~org-babel-post-tangle-hook~. Once
again, it would be preferred if this was done locally, but it needs to be
global. To avoid this causing headaches down the line we'll make sure when
implementing the hook function to have it remove itself from the hook when
executed.

#+name: confpkg-setup
#+begin_src emacs-lisp :results silent :noweb no-export
(setq confpkg--num 0
      confpkg--list nil)

;; provide functions to be used in confpkg-tangle-finalize
<<confpkg-dependency-analysis>>
<<confpkg-strip-package-statements>>
<<confpkg-create-config>>
(defun confpkg-cleanup ()
 <<confpkg-cleanup>>
  )
<<confpkg-finalizer>>

;; executed right away and not just a function definition
<<confpkg-clear-old-files>>

(add-hook 'org-babel-tangle-finished-hook #'confpkg-tangle-finalize)
#+end_src

To avoid generating cruft, it would also be good to get rid of old tangled
config files at the start.

#+name: confpkg-clear-old-files
#+begin_src emacs-lisp
(make-directory "subconf" t)
(dolist (conf-file (directory-files "subconf" t "config-.*\\.el"))
  (delete-file conf-file))
#+end_src

Now to have this take effect, we can just use a babel call keyword. Thanks to
the preparation step this will be executed during tangling.

#+call: confpkg-setup[:results none]()

*** package generation

Now we actually implement the =confpkg= babel function. We could just direct the
output into the =subconf/config-X.el= file without any extra steps, but why not be
a bit fancier and make it more like a package.

To do this, we'll have =confpkg= load a template and then fill it in using
~format-spec~. To make sure this is actually used, we'll call ~org-set-property~ to
modify the parent heading, and register the config group with the variables we
created earlier.

#+name: confpkg
#+begin_src elisp :var name="" needs="" after="" pre="" prefix="config-" via="copy" emacs-minimum="29.1" :results raw :noweb no-export
;; Babel block for use with #+call
;; Arguments:
;;  - name, the name of the config sub-package
;;  - needs, (when non-empty) required system executable(s)
;;  - after, required features as a string or vector of strings
;;  - pre, a noweb reference to code that should be executed eagerly,
;;    and not deferred via after. The code is not included in the
;;    generated .el file and should only be used in dire situations.
;;  - prefix, the package prefix ("config-" by default)
;;  - via, how this configuration should be included in config.el,
;;    the current options are:
;;    + "copy", copy the configuration lisp
;;    + "require", insert a require statement
;;    + "none", do not do anything to load this configuration.
;;      This only makes sense when configuration is either being
;;      temporarily disabled or loaded indirectly/elsewhere.
;;  - emacs-minimum, the minimum emacs version ("29.1" by default)
(when (or (string-empty-p needs)
          (cl-every #'executable-find (delq nil (split-string needs ","))))
  (let* ((name (if (string-empty-p name)
                   (save-excursion
                     (and (org-back-to-heading-or-point-min t)
                          (substring-no-properties
                           (org-element-interpret-data
                            (org-element-property :title (org-element-at-point))))))
                 name))
         (after
          (cond
           ((and (stringp after) (string-empty-p after)) nil)
           ((and (stringp after) (string-match-p "\\`[^()]+\\'" after))
            (intern after)) ; Single feature.
           ((and (vectorp after) (cl-every #'stringp after))
            (nconc (list :and) (mapcar #'intern after)))
           (t nil)))
         (pre (and (not (string-empty-p pre)) pre))
         (confpkg-name
          (concat prefix (replace-regexp-in-string
                          "[^a-z-]" "-" (downcase name))))
         (confpkg-file (expand-file-name (concat confpkg-name ".el")
                                         "subconf")))
    (unless (file-exists-p confpkg-file)
      (make-empty-file confpkg-file t))
    (cl-incf confpkg--num)
    (org-set-property
     "header-args:emacs-lisp"
     (format ":tangle no :noweb-ref %s :noweb-sep \"\\n\\n\"" confpkg-name))
    (push (list :name name
                :package confpkg-name
                :file confpkg-file
                :after after
                :pre pre
                :via (intern via)
                :package-statements nil)
          confpkg--list)
    (format-spec
     "#+begin_src emacs-lisp :tangle %f :mkdirp yes :noweb no-export :noweb-ref none :comments no
<<confpkg-template>>
,#+end_src"
     `((?n . ,confpkg--num)
       (?p . ,confpkg-name)
       (?f . ,confpkg-file)
       (?e . ,emacs-minimum)
       (?Y . ,(format-time-string "%Y"))
       (?B . ,(format-time-string "%B"))
       (?m . ,(format-time-string "%m"))
       (?d . ,(format-time-string "%d"))
       (?M . ,(format-time-string "%M"))
       (?S . ,(format-time-string "%S"))))))
#+end_src

Now all that's needed is a template to be used.

#+name: confpkg-template
#+begin_src emacs-lisp :eval no
;;; %p.el --- Generated package (no.%n) from my config -*- lexical-binding: t; -*-
;;
;; Author: aesbetic
;; Maintainer: aesbetic
;; Created: %B %d, %Y
;; Modified: %B %d, %Y
;; Version: %Y.%m.%d
;; Homepage: https://github.com/ekattsim
;; Package-Requires: ((emacs \"%e\"))
;;
;; This file is not part of GNU Emacs.
;;
;;; Commentary:
;;
;;  Generated package (no.%n) from my config.
;;
;;  During generation, dependency on other aspects of my configuration and
;;  packages is inferred via (regexp-based) static analysis.  While this seems
;;  to do a good job, this method is imperfect.  This code likely depends on
;;  utilities provided by Doom, and if you try to run it in isolation you may
;;  discover the code makes more assumptions.
;;
;;  That said, I've found pretty good results so far.
;;
;;; Code:

<<%p>>

(provide '%p)
;;; %p.el ends here
#+end_src

This currently makes the included content look much more package-like than it
truly is.

Lastly, should there be an issue or interruption, it's possible that the
modifications from =#+call: confpkg= may persist. If I've been good with my
committing, resolving this should be as simple as reverting unstaged changes.
So... back in reality, it would be nice to have a way to clean up =confpkg=
residue.

#+name: confpkg-cleanup
#+begin_src emacs-lisp :results none
(org-fold-core-ignore-fragility-checks
  (org-babel-map-executables nil
    (when (and (eq (org-element-type (org-element-context)) 'babel-call)
               (equal (org-element-property :call (org-element-context)) "confpkg"))
      (org-babel-remove-result)
      (org-entry-delete nil "header-args:emacs-lisp"))))
#+end_src

*** identify cross-package dependencies
:PROPERTIES:
:header-args:emacs-lisp: :noweb-ref confpkg-dependency-analysis
:END:

At a basic level, we can search for regexp expressions indicating the definition
of functions or variables and search for their usage.

#+begin_src emacs-lisp
(defun confpkg--rough-extract-definitions (file)
  (with-temp-buffer
    (insert-file-contents file)
    (goto-char (point-min))
    (let (symbols)
      (while (re-search-forward
              (rx line-start (* (any ?\s ?\t)) "("
                  (or "defun" "defmacro" "defsubst" "defgeneric" "defalias" "defvar" "defcustom" "defface" "deftheme"
                      "cl-defun" "cl-defmacro" "cl-defsubst" "cl-defmethod" "cl-defstruct" "cl-defgeneric" "cl-deftype")
                  (+ (any ?\s ?\t))
                  (group (+ (any "A-Z" "a-z" "0-9"
                                 ?+ ?- ?* ?/ ?_ ?~ ?! ?@ ?$ ?% ?^ ?& ?= ?: ?< ?> ?{ ?})))
                  (or blank ?\n))
              nil t)
        (push (match-string 1) symbols))
      symbols)))
#+end_src

Continuing our rough regexp approach, we can construct a similar function to
look for uses of symbols.

#+begin_src emacs-lisp
(defun confpkg--rough-uses-p (file symbols)
  (with-temp-buffer
    (insert-file-contents file)
    (let ((symbols (copy-sequence symbols)) uses-p)
      (while symbols
        (goto-char (point-min))
        (if (re-search-forward (rx word-start (literal (car symbols)) word-end) nil t)
            (setq uses-p t symbols nil)
          (setq symbols (cdr symbols))))
      uses-p)))
#+end_src

Now we can put these two functions together to annotate ~confpkg--list~ with their
(confpkg) dependencies.

#+begin_src emacs-lisp
(defun confpkg-annotate-list-dependencies ()
  (dolist (confpkg confpkg--list)
    (plist-put confpkg :defines
               (confpkg--rough-extract-definitions
                (plist-get confpkg :file))))
  (dolist (confpkg confpkg--list)
    (let ((after (plist-get confpkg :after))
          requires)
      (dolist (other-confpkg confpkg--list)
        (when (and (not (eq other-confpkg confpkg))
                   (confpkg--rough-uses-p (plist-get confpkg :file)
                                          (plist-get other-confpkg :defines)))
          (push (plist-get other-confpkg :package) requires)))
      (when (and after (symbolp after))
        (push after requires))
      (plist-put confpkg :requires requires))))
#+end_src

Finally, we can use this information to edit the confpkg files to add the
necessary ~require~ statements.

#+begin_src emacs-lisp
(defun confpkg-write-dependencies ()
  (dolist (confpkg confpkg--list)
    (when (plist-get confpkg :requires)
      (with-temp-buffer
        (setq buffer-file-name (plist-get confpkg :file))
        (insert-file-contents buffer-file-name)
        (re-search-forward "^;;; Code:\n")
        (insert "\n")
        (dolist (req (plist-get confpkg :requires))
          (insert (format "(require '%s)\n" req)))
        (write-region nil nil buffer-file-name)
        (set-buffer-modified-p nil)))))
#+end_src

*** commenting out ~package!~ statements

It's easy enough to set ~package!~ statements to tangle to =packages.el=, however
with our noweb ref approach they will /also/ go to the config files. This could be
viewed as a problem, but I actually think it's rather nice to have the package
information with the config. So, we can look for an immediate ~package!~ statement
and simply comment it out. As a bonus, we can also then record which packages
are needed for each block of config.

#+name: confpkg-strip-package-statements
#+begin_src emacs-lisp
(defun confpkg-comment-out-package-statements ()
  (dolist (confpkg confpkg--list)
    (with-temp-buffer
      (setq buffer-file-name (plist-get confpkg :file))
      (insert-file-contents buffer-file-name)
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*(\\(package!\\|unpin!\\)[[:space:]\n]+\\([^[:space:]]+\\)\\b" nil t)
        (plist-put confpkg :package-statements
                   (nconc (plist-get confpkg :package-statements)
                          (list (match-string 2))))
        (let* ((start (progn (beginning-of-line) (point)))
               (end (progn (forward-sexp 1)
                           (if (looking-at "[\t ]*;.*")
                               (line-end-position)
                             (point))))
               (contents (buffer-substring start end))
               paste-start paste-end
               (comment-start ";")
               (comment-padding "   ")
               (comment-end ""))
          (delete-region start (1+ end))
          (re-search-backward "^;;; Code:")
          (beginning-of-line)
          (insert ";;  Package statement:\n")
          (setq paste-start (point))
          (insert contents)
          (setq paste-end (point))
          (insert  "\n;;\n")
          (comment-region paste-start paste-end 2)))
      (when (buffer-modified-p)
        (write-region nil nil buffer-file-name)
        (set-buffer-modified-p nil)))))
#+end_src

*** creating the config file

After all the subconfig files have been tangled, we need to collect their
content and put them together into =config.el=. For this, all that's needed is a
function to go through the registered config groups and put their content in a
tempbuffer. We can call this with the finalising step.

#+name: confpkg-create-config
#+begin_src emacs-lisp
(defun confpkg-create-config ()
  (let ((revert-without-query '("config\\.el"))
        (original-buffer (current-buffer)))
    (with-temp-buffer
      (insert
       (format ";;; config.el -*- lexical-binding: t; -*-

;; Generated at %s from the literate configuration.

(add-to-list 'load-path %S)\n"
               (format-time-string "%FT%T%z")
               (replace-regexp-in-string
                (regexp-quote (getenv "HOME")) "~"
                (expand-file-name "subconf/"))))
      (mapc
       (lambda (confpkg)
         (insert
          (if (eq 'none (plist-get confpkg :via))
              (format "\n;;; %s intentionally omitted.\n" (plist-get confpkg :name))
            (with-temp-buffer
              (cond
               ((eq 'copy (plist-get confpkg :via))
                (insert-file-contents (plist-get confpkg :file))
                (goto-char (point-min))
                (narrow-to-region
                 (re-search-forward "^;;; Code:\n+")
                 (progn
                   (goto-char (point-max))
                   (re-search-backward (format "[^\n\t ][\n\t ]*\n[\t ]*(provide '%s)" (plist-get confpkg :package)))
                   (match-end 0))))
               ((eq 'require (plist-get confpkg :via))
                (insert (format "(require '%s)\n" (plist-get confpkg :package))))
               (t (insert (format "(warn \"%s confpkg :via has unrecognised value: %S\" %S %S)"
                                  (plist-get confpkg :name) (plist-get confpkg :via)))))
              (goto-char (point-min))
              (insert "\n;;:------------------------"
                      "\n;;; " (plist-get confpkg :name)
                      "\n;;:------------------------\n\n")
              (when (plist-get confpkg :defines)
                (insert ";; This block defines "
                        (mapconcat
                         (lambda (d) (format "`%s'" d))
                         (plist-get confpkg :defines)
                         ", ")
                        ".")
                (when (re-search-backward "\\([^, ]+\\), \\([^, ]+\\), \\([^, ]+\\).\\="
                                          (line-beginning-position) t)
                  (replace-match "\\1, \\2, and \\3."))
                (when (re-search-backward "\\([^, ]+\\), \\([^, ]+\\).\\="
                                          (line-beginning-position) t)
                  (replace-match "\\1 and \\2."))
                (insert "\n\n")
                (forward-line -2)
                (setq-local comment-start ";")
                (fill-comment-paragraph)
                (forward-paragraph 1)
                (forward-line 1))
              (if (equal (plist-get confpkg :package) "config-confpkg-timings")
                  (progn
                    (goto-char (point-max))
                    (insert "\n\n\
(confpkg-create-record 'doom-pre-config (float-time (time-subtract (current-time) before-init-time)))
(confpkg-start-record 'config)
(confpkg-create-record 'config-defered 0.0 'config)
(confpkg-create-record 'set-hooks 0.0 'config-defered)
(confpkg-create-record 'load-hooks 0.0 'config-defered)
(confpkg-create-record 'requires 0.0 'root)\n"))
                (let ((after (plist-get confpkg :after))
                      (pre (and (plist-get confpkg :pre)
                                (org-babel-expand-noweb-references
                                 (list "emacs-lisp"
                                       (format "<<%s>>" (plist-get confpkg :pre))
                                       '((:noweb . "yes")
                                         (:comments . "none")))
                                 original-buffer)))
                      (name (replace-regexp-in-string
                             "config--?" ""
                             (plist-get confpkg :package))))
                  (if after
                      (insert (format "(confpkg-with-record '%S\n"
                                      (list (concat "hook: " name) 'set-hooks))
                              (if pre
                                  (concat ";; Begin pre\n" pre "\n;; End pre\n")
                                "")
                              (format (if (symbolp after) ; If single feature.
                                          "  (with-eval-after-load '%s\n"
                                        "  (after! %s\n")
                                      after))
                    (when pre
                      (insert "\n;; Begin pre (unnecesary since after is unused)\n"
                              pre
                              "\n;; End pre\n")))
                  (insert
                   (format "(confpkg-with-record '%S\n"
                           (list (concat "load: " name)
                                 (if after 'load-hooks 'config)))))
                (goto-char (point-max))
                (when (string-match-p ";" (thing-at-point 'line))
                  (insert "\n"))
                (insert ")")
                (when (plist-get confpkg :after)
                  (insert "))"))
                (insert "\n"))
              (buffer-string)))))
       (let ((confpkg-timings ;; Ensure timings is put first.
              (cl-some (lambda (p) (and (equal (plist-get p :package) "config-confpkg-timings") p))
                       confpkg--list)))
         (append (list confpkg-timings)
                 (nreverse (remove confpkg-timings confpkg--list)))))
      (insert "\n(confpkg-finish-record 'config)\n\n;;; config.el ends here")
      (write-region nil nil "config.el" nil :silent))))
#+end_src

Applying lexical binding to the config file is good for a number of reasons,
among which it's (slightly) faster than dynamic binding (see [[https://nullprogram.com/blog/2016/12/22/][this blog post]] for
more info).

*** quieter output

All the babel evaluation here ends up being quite noisy (along with a few other
things during tangle), let's see if we can change that.

#+name: confpkg-quieter-output
#+begin_src emacs-lisp
(when noninteractive
  (unless (fboundp 'doom-shut-up-a)
    (defun doom-shut-up-a (fn &rest args)
      (let ((standard-output #'ignore)
            (inhibit-message t))
        (apply fn args))))
  (advice-add 'org-babel-expand-body:emacs-lisp :around #'doom-shut-up-a)
  ;; Quiet some other annoying messages
  (advice-add 'sh-set-shell :around #'doom-shut-up-a)
  (advice-add 'rng-what-schema :around #'doom-shut-up-a)
  (advice-add 'python-indent-guess-indent-offset :around #'doom-shut-up-a))
#+end_src

#+call: confpkg-quieter-output()

*** reporting load time information

#+call: confpkg("Confpkg timings")

When generating the config we added a form to collect load-time information.

#+begin_src emacs-lisp
(defvar confpkg-load-time-tree (list (list 'root)))
(defvar confpkg-record-branch (list 'root))
(defvar confpkg-record-num 0)
#+end_src

It would be good to process ~confpkg-load-times~ at the end to make it more
useful, and provide a function to display load time information from it. This is
to aid in identification of confpkgs that take particularly long to load, and
thus would benefit from some attention.

To extract the per-confpkg load times, we can just take the difference in
~(float-time)~ and exclude the first entry.

#+begin_src emacs-lisp
(defun confpkg-create-record (name elapsed &optional parent enclosing)
  (let ((parent (assoc (or parent (car confpkg-record-branch))
                       confpkg-load-time-tree))
        (record (cons name (list (list 'self
                                       :name (format "%s" name)
                                       :num (cl-incf confpkg-record-num)
                                       :elapsed elapsed
                                       :enclosing enclosing)))))
    (push record confpkg-load-time-tree)
    (push record (cdr parent))
    record))

(defun confpkg-start-record (name &optional parent)
  (let ((record (confpkg-create-record name 0.0e+NaN parent t)))
    (plist-put (cdadr record) :start (float-time))
    (push name confpkg-record-branch)
    record))

(defun confpkg-finish-record (name)
  (let ((self-record (cdar (last (cdr (assoc name confpkg-load-time-tree))))))
    (plist-put self-record :elapsed
               (- (float-time) (plist-get self-record :start) 0.0))
    (unless (equal (car confpkg-record-branch) name)
      (message "Warning: Confpkg timing record expected to finish %S, instead found %S. %S"
               name (car confpkg-record-branch) confpkg-record-branch))
    (setq confpkg-record-branch (cdr confpkg-record-branch))))
#+end_src

A convenience macro could be nice to have.

#+begin_src emacs-lisp
(defmacro confpkg-with-record (name &rest body)
  "Create a time record around BODY.
The record must have a NAME."
  (declare (indent 1))
  (let ((name-val (make-symbol "name-val"))
        (record-spec (make-symbol "record-spec")))
    `(let* ((,name-val ,name)
            (,record-spec (if (consp ,name-val) ,name-val (list ,name-val))))
       (apply #'confpkg-start-record ,record-spec)
       (unwind-protect
           (progn ,@body)
         (confpkg-finish-record (car ,record-spec))))))
#+end_src

It would also be nice to collect some other load-time-related information.

#+begin_src emacs-lisp
(defadvice! +require--log-timing-a (orig-fn feature &optional filename noerror)
  :around #'require
  (if (or (featurep feature)
          (eq feature 'cus-start) ; HACK Why!?!
          (assoc (format "require: %s" feature) confpkg-load-time-tree))
      (funcall orig-fn feature filename noerror)
    (confpkg-with-record (list (format "require: %s" feature)
                               (and (eq (car confpkg-record-branch) 'root)
                                    'requires))
      (funcall orig-fn feature filename noerror))))
#+end_src

At last, we'll go to some pains to make a nice result tabulation function.

I will readily admit that this function is absolutely horrible. I just spent an
evening adding to it till it worked then stopped touching it. Maybe in the
future I'll go back to it and try to clean up the implementation.

#+begin_src emacs-lisp
(defun confpkg-timings-report (&optional sort-p node)
  "Display a report on load-time information.
Supply SORT-P (or the universal argument) to sort the results.
NODE defaults to the root node."
  (interactive
   (list (and current-prefix-arg t)))
  (let ((buf (get-buffer-create "*Confpkg Load Time Report*"))
        (depth 0)
        num-pad name-pad max-time max-total-time max-depth)
    (cl-labels
        ((sort-records-by-time
          (record)
          (let ((self (assoc 'self record)))
            (append (list self)
                    (sort (nreverse (remove self (cdr record)))
                          (lambda (a b)
                            (> (or (plist-get (alist-get 'self a) :total) 0.0)
                               (or (plist-get (alist-get 'self b) :total) 0.0)))))))
         (print-record
          (record)
          (cond
           ((eq (car record) 'self)
            (insert
             (propertize
              (string-pad (number-to-string (plist-get (cdr record) :num)) num-pad)
              'face 'font-lock-keyword-face)
             " "
             (propertize
              (apply #'concat
                     (make-list (1- depth) "• "))
              'face 'font-lock-comment-face)
             (string-pad (format "%s" (plist-get (cdr record) :name)) name-pad)
             (make-string (* (- max-depth depth) 2) ?\s)
             (propertize
              (format "%.4fs" (plist-get (cdr record) :elapsed))
              'face
              (list :foreground
                    (doom-blend 'orange 'green
                                (/ (plist-get (cdr record) :elapsed) max-time))))
             (if (= (plist-get (cdr record) :elapsed)
                    (plist-get (cdr record) :total))
                 ""
               (concat "   (Σ="
                       (propertize
                        (format "%.3fs" (plist-get (cdr record) :total))
                        'face
                        (list :foreground
                              (doom-blend 'orange 'green
                                          (/ (plist-get (cdr record) :total) max-total-time))))
                       ")"))
             "\n"))
           (t
            (cl-incf depth)
            (mapc
             #'print-record
             (if sort-p
                 (sort-records-by-time record)
               (reverse (cdr record))))
            (cl-decf depth))))
         (flatten-records
          (records)
          (if (eq (car records) 'self)
              (list records)
            (mapcan
             #'flatten-records
             (reverse (cdr records)))))
         (tree-depth
          (records &optional depth)
          (if (eq (car records) 'self)
              (or depth 0)
            (1+ (cl-reduce #'max (cdr records) :key #'tree-depth))))
         (mapreduceprop
          (list map reduce prop)
          (cl-reduce
           reduce list
           :key
           (lambda (p) (funcall map (plist-get (cdr p) prop)))))
         (elaborate-timings
          (record)
          (if (eq (car record) 'self)
              (plist-get (cdr record) :elapsed)
            (let ((total (cl-reduce #'+ (cdr record)
                                    :key #'elaborate-timings))
                  (self (cdr (assoc 'self record))))
              (if (plist-get self :enclosing)
                  (prog1
                      (plist-get self :elapsed)
                    (plist-put self :total (plist-get self :elapsed))
                    (plist-put self :elapsed
                               (- (* 2 (plist-get self :elapsed)) total)))
                (plist-put self :total total)
                total))))
         (elaborated-timings
          (record)
          (let ((record (copy-tree record)))
            (elaborate-timings record)
            record)))
      (let* ((tree
              (elaborated-timings
               (append '(root)
                       (copy-tree
                        (alist-get (or node 'root)
                                   confpkg-load-time-tree
                                   nil nil #'equal))
                       '((self :num 0 :elapsed 0)))))
             (flat-records
              (cl-remove-if
               (lambda (rec) (= (plist-get (cdr rec) :num) 0))
               (flatten-records tree))))
        (setq max-time (mapreduceprop flat-records #'identity #'max :elapsed)
              max-total-time (mapreduceprop flat-records #'identity #'max :total)
              name-pad (mapreduceprop flat-records #'length #'max :name)
              num-pad (mapreduceprop flat-records
                                     (lambda (n) (length (number-to-string n)))
                                     #'max :num)
              max-depth (tree-depth tree))
        (with-current-buffer buf
          (erase-buffer)
          (setq-local outline-regexp "[0-9]+ *\\(?:• \\)*")
          (outline-minor-mode 1)
          (use-local-map (make-sparse-keymap))
          (local-set-key "TAB" #'outline-toggle-children)
          (local-set-key "\t" #'outline-toggle-children)
          (local-set-key (kbd "<backtab>") #'outline-show-subtree)
          (local-set-key (kbd "C-<iso-lefttab>")
                         (eval `(cmd! (if current-prefix-arg
                                          (outline-show-all)
                                        (outline-hide-sublevels (+ ,num-pad 2))))))
          (insert
           (propertize
            (concat (string-pad "#" num-pad) " "
                    (string-pad "Confpkg"
                                (+ name-pad (* 2 max-depth) -3))
                    (format " Load Time (Σ=%.3fs)\n"
                            (plist-get (cdr (assoc 'self tree)) :total)))
            'face '(:inherit (tab-bar-tab bold) :extend t :underline t)))
          (dolist (record (if sort-p
                              (sort-records-by-time tree)
                            (reverse (cdr tree))))
            (unless (eq (car record) 'self)
              (print-record record)))
          (set-buffer-modified-p nil)
          (goto-char (point-min)))
        (pop-to-buffer buf)))))
#+end_src

*** finalize

At last, to clean up the content inserted by the babel calls we can just revert
the buffer. As long as ~org-babel-pre-tangle-hook~ hasn't been modified,
~save-buffer~ will be run at the start of the tangle process and so reverting will
take us back to just before the tangle started.

Since this is /the/ function added as the post-tangle hook, we also need to remove
the function from the hook and call the =config.el= creation function.

#+name: confpkg-finalizer
#+begin_src emacs-lisp
(defun confpkg-tangle-finalize ()
  (remove-hook 'org-babel-tangle-finished-hook #'confpkg-tangle-finalize)
  (revert-buffer t t t)
  (confpkg-comment-out-package-statements)
  (confpkg-annotate-list-dependencies)
  (confpkg-create-config)
  (confpkg-write-dependencies)
  (message "Processed %s elisp files" (length confpkg--list)))
#+end_src

Within ~confpkg-tangle-finalize~ we carefully order each step so that
the most important steps go first, to minimise the impact should a particular
step fail.

** doom modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref none
:END:

Modules need to be declared in [[file:init.el][init.el]]. Doom comes with a lot of features so when you find some flashy new functionality, you should first check whether doom has a related module.

#+name: init.el
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :noweb-ref none
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :input
       <<doom-input>>

       :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src

*** structure

Enable the =literate= module which tangles source blocks from =$DOOMDIR/config.org= to =config.el= on =doom sync=. There's also the =default= module which sets up default bindings, etc.

#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

*** input

#+name: doom-input
#+begin_src emacs-lisp
;;bidi              ; (tfel ot) thgir etirw uoy gnipleh
;;chinese
;;japanese
;;layout            ; auie,ctsrnm is the superior home row
#+end_src

*** interface

group of doom modules that make up the emacs interface.

#+name: doom-completion
#+begin_src emacs-lisp
;;company           ; the ultimate code completion backend
(corfu +orderless)  ; complete with cap(f), cape and a flying feather!
;;helm              ; the *other* search engine for love and life
;;ido               ; the other *other* search engine...
;;ivy               ; a search engine for love and life
vertico           ; the search engine of the future
#+end_src

#+name: doom-ui
#+begin_src emacs-lisp
;;deft              ; notational velocity for emacs
doom              ; what makes doom look the way it does
doom-dashboard    ; a nifty splash screen for emacs
;;doom-quit         ; doom quit-message prompts when you quit emacs
;;(emoji +unicode)  ; 🙂
hl-todo           ; highlight todo/fixme/note/deprecated/hack/review
;;indent-guides     ; highlighted indent columns
;;ligatures         ; ligatures and symbols to make your code pretty again
;;minimap           ; show a map of the code on the side
;;modeline          ; snazzy, atom-inspired modeline, plus api
;;nav-flash         ; blink cursor line after big motions
;;neotree           ; a project drawer, like nerdtree for vim
ophints           ; highlight the region an operation acts on
(popup +defaults)   ; tame sudden yet inevitable temporary windows
;;tabs              ; a tab bar for emacs
;;treemacs          ; a project drawer, like neotree but cooler
;;unicode           ; extended unicode support for various languages
(vc-gutter +pretty) ; vcs diff in the fringe
;;vi-tilde-fringe   ; fringe tildes to mark beyond eob
;;window-select     ; visually switch windows
workspaces        ; tab emulation, persistence & separate workspaces
zen               ; distraction-free coding or writing (todo)
#+end_src

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere); come to the dark side, we have cookies
file-templates    ; auto-snippets for empty files
fold              ; (nigh) universal code folding
;;(format +onsave)  ; automated prettiness
;;god               ; run emacs commands without modifier keys
;;lispy             ; vim for lisp, for people who don't like vim
;;multiple-cursors  ; editing in many places at once
;;objed             ; text object editing for the innocent
;;parinfer          ; turn lisp into python, sort of
;;rotate-text       ; cycle region at point between text candidates
snippets          ; my elves. they type so i don't have to
;;word-wrap         ; soft wrapping with language-aware indent
#+end_src

#+name: doom-emacs
#+begin_src emacs-lisp
dired             ; making dired pretty [functional]
electric          ; smarter, keyword-based electric-indent
;;eww               ; the internet is gross
;;ibuffer           ; interactive buffer management
undo              ; persistent, smarter undo for your inevitable mistakes
vc                ; version-control and emacs, sitting in a tree
#+end_src

#+name: doom-term
#+begin_src emacs-lisp
;;eshell            ; the elisp shell that works everywhere
;;shell             ; simple shell repl for emacs
;;term              ; basic terminal emulator for emacs
vterm             ; the best terminal emulation in emacs
#+end_src

#+name: doom-checkers
#+begin_src emacs-lisp
syntax              ; tasing you for every semicolon you forget
;;(spell +flyspell) ; tasing you for misspelling mispelling
;;grammar           ; tasing grammar mistake every you make
#+end_src

#+name: doom-tools
#+begin_src emacs-lisp
;;ansible
;;biblio            ; writes a phd for you (citation needed)
;;collab            ; buffers with friends
;;debugger          ; fixme stepping through code, to help you add bugs
;;direnv
;;docker
;;editorconfig      ; let someone else argue about tabs vs spaces
;;ein               ; tame jupyter notebooks with emacs
(eval +overlay)     ; run code, run (also, repls)
lookup              ; navigate your code and its documentation
(lsp +eglot)               ; m-x vscode
magit             ; a git porcelain for emacs
;;make              ; run make tasks from emacs
;;pass              ; password manager for nerds
pdf               ; pdf enhancements
;;prodigy           ; fixme managing external services & code builders
;;terraform         ; infrastructure as code
;;tmux              ; an api for interacting with tmux
tree-sitter       ; syntax and parsing, sitting in a tree...
;;upload            ; map local to remote projects via ssh/ftp
#+end_src

#+name: doom-os
#+begin_src emacs-lisp
(:if (featurep :system 'macos) macos)  ; improve compatibility with macos
;;tty               ; improve the terminal emacs experience
#+end_src

*** language support
:properties:
:id:       41ff62d2-069a-4c9e-a6ea-3ea737ea41ab
:end:

language modules are lazy-loaded so we might as well enable all we want.

#+name: doom-lang
#+begin_src emacs-lisp
;;agda              ; types of types of types of types...
;;beancount         ; mind the gaap
(cc +lsp)         ; c > c++ == 1
;;clojure           ; java with a lisp
;;common-lisp       ; if you've seen one lisp, you've seen them all
;;coq               ; proofs-as-programs
;;crystal           ; ruby at the speed of c
;;csharp            ; unity, .net, and mono shenanigans
;;data              ; config/data formats
;;(dart +flutter)   ; paint ui and not much else
;;dhall
;;elixir            ; erlang done right
;;elm               ; care for a cup of tea?
emacs-lisp        ; drown in parentheses
;;erlang            ; an elegant language for a more civilized age
;;ess               ; emacs speaks statistics
;;factor
;;faust             ; dsp, but you get to keep your soul
;;fortran           ; in fortran, god is real (unless declared integer)
;;fsharp            ; ml stands for microsoft's language
;;fstar             ; (dependent) types and (monadic) effects and z3
;;gdscript          ; the language you waited for
;;(go +lsp)         ; the hipster dialect
;;(graphql +lsp)    ; give queries a rest
;;(haskell +lsp)    ; a language that's lazier than i am
;;hy                ; readability of scheme w/ speed of python
;;idris             ; a language you can depend on
;;json              ; at least it ain't xml
;;(java +lsp)       ; the poster child for carpal tunnel syndrome
;;javascript        ; all(hope(abandon(ye(who(enter(here))))))
;;julia             ; a better, faster matlab
;;kotlin            ; a better, slicker java(script)
(latex +cdlatex)             ; writing papers in emacs has never been so fun
;;lean              ; for folks with too much to prove
;;ledger            ; be audit you can be
lua               ; one-based indices? one-based indices
markdown          ; writing docs for people to ignore
;;nim               ; python + lisp at the speed of c
;;nix               ; i hereby declare "nix geht mehr!"
;;ocaml             ; an objective camel
(org +roam2)               ; organize your plain life in plain text
;;php               ; perl's insecure younger brother
;;plantuml          ; diagrams for confusing people more
;;graphviz          ; diagrams for confusing yourself even more
;;purescript        ; javascript, but functional
(python +lsp +tree-sitter)            ; beautiful is better than ugly
;;qt                ; the 'cutest' gui framework ever
;;racket            ; a dsl for dsls
;;raku              ; the artist formerly known as perl6
;;rest              ; emacs as a rest client
;;rst               ; rest in peace
;;(ruby +rails)     ; 1.step {|i| p "ruby is #{i.even? ? 'love' : 'life'}"}
;;(rust +lsp)       ; fe2o3.unwrap().unwrap().unwrap().unwrap()
;;scala             ; java, but good
;;(scheme +guile)   ; a fully conniving family of lisps
sh                ; she sells {ba,z,fi}sh shells on the c xor
;;sml
;;solidity          ; do you need a blockchain? no.
;;swift             ; who asked for emoji variables?
;;terra             ; earth and moon in alignment for performance.
(web +lsp +tree-sitter)               ; the tubes
;;yaml              ; json, but readable
;;zig               ; c, but simpler
#+end_src

*** applications

#+name: doom-email
#+begin_src emacs-lisp
;;(mu4e +org +gmail)
;;notmuch
;;(wanderlust +gmail)
#+end_src

#+name: doom-app
#+begin_src emacs-lisp
;;calendar
;;emms
;;everywhere        ; *leave* emacs!? you must be joking
;;irc               ; how neckbeards socialize
rss        ; emacs as an rss reader
#+end_src

** package management
:PROPERTIES:
:header-args:emacs-lisp: :noweb-ref none
:END:

Tangle the default instructions to packages.el. This is also where all the package declarations will be tangled to.

#+begin_src emacs-lisp :tangle "packages.el"
;; -*- no-byte-compile: t; -*-

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or


;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;; (package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/radian-software/straight.el#the-recipe-format
;; (package! another-package
;;   :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;; (package! this-package
;;   :recipe (:host github :repo "username/repo"
;;            :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;; (package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;; (package! builtin-package :recipe (:nonrecursive t))
;; (package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see radian-software/straight.el#279)
;; (package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
;; (package! builtin-package :pin "1a2b3c4d5e")


;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;; (unpin! pinned-package)
;; ...or multiple packages
;; (unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;; (unpin! t)
#+end_src

*** use-package
#+call: confpkg()

I don't like the automatic insertion of "-hook" suffix. It breaks =K=.

#+begin_src emacs-lisp
(setq use-package-hook-name-suffix nil)
#+end_src

** customize

Autoload the custom.el file if it exists.

#+BEGIN_SRC emacs-lisp
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

* system configuration
#+call: confpkg("system")

As is often pointed out, Emacs is more of an operating system than a text editor. This section concerns itself with configuring the system part.

** Admin stuff

I'm not exactly sure where this information is used but here goes anyway.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Aesbetic"
      user-mail-address "aesbetic@gmail.com")
#+END_SRC

** UI

*** General

Remove the title bar because it's unaesthetic.

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(undecorated-round . t))
#+END_SRC

*** Theme

Load theme, taking current system appearance into consideration.

*Note:* I might remove this if it gets dark outside too quick.
#+BEGIN_SRC emacs-lisp
(defun my/apply-theme (appearance)
  (mapc #'disable-theme custom-enabled-themes)
  (pcase appearance
    ('light (when (not (featurep 'nano-modeline))
                (load "/Users/abhijeetsurakanti/.config/doom/subconf/config-nano-modeline.el" nil t)
                (nano-modeline-text-mode t))
            (load-theme 'doom-homage-white t))

    ('dark (when (featurep 'nano-modeline)
               (unload-feature 'nano-modeline))
           (load-theme 'doom-homage-black t)))
  (load-file "/Users/abhijeetsurakanti/.config/doom/subconf/config-org-aesthetics.el")) ;; first use of confpkg!!!

(add-hook 'ns-system-appearance-change-functions #'my/apply-theme)
#+END_SRC

*** Fonts

Add Roboto Mono and Source Sans Pro as fixed and variable pitch fonts respectively.

#+BEGIN_SRC emacs-lisp
(when (member "Roboto Mono" (font-family-list))
  (setq doom-font (font-spec :family "Roboto Mono" :height 15.0)))
  ;; (set-face-attribute 'default nil :family "Roboto Mono" :height 150)
  ;; (set-face-attribute 'fixed-pitch nil :family "Roboto Mono"))

(when (member "Source Sans Pro" (font-family-list))
  ;; variable pitch font will be a little larger than fixed fonts
  (setq doom-variable-pitch-font (font-spec :family "Source Sans Pro" :size 18.0)))
  ;; (set-face-attribute 'variable-pitch nil :family "Source Sans Pro" :height 1.20))
#+END_SRC

*** Modeline
#+call: confpkg(name="nano-modeline")

Let's experiment with a more minimal modeline. I've been meaning to try out something from the [[https://github.com/rougier/nano-emacs?tab=readme-ov-file][nano-emacs]] collection so let's use their modeline package.

#+begin_src emacs-lisp :tangle "packages.el"
(package! nano-modeline)
#+end_src

#+begin_src emacs-lisp
(use-package! nano-modeline
  :hook ((prog-mode-hook            . nano-modeline-prog-mode)
         (text-mode-hook            . nano-modeline-text-mode)
         (org-mode-hook             . nano-modeline-org-mode)
         (pdf-view-mode-hook        . nano-modeline-pdf-mode)
         (mu4e-headers-mode-hook    . nano-modeline-mu4e-headers-mode)
         (mu4e-view-mode-hook       . nano-modeline-mu4e-message-mode)
         (elfeed-show-mode-hook     . nano-modeline-elfeed-entry-mode)
         (elfeed-search-mode-hook   . nano-modeline-elfeed-search-mode)
         (term-mode-hook            . nano-modeline-term-mode)
         (xwidget-webkit-mode-hook  . nano-modeline-xwidget-mode)
         (messages-buffer-mode-hook . nano-modeline-message-mode)
         (org-capture-mode-hook     . nano-modeline-org-capture-mode)
         (org-agenda-mode-hook      . nano-modeline-org-agenda-mode))
  :config
  (setq nano-modeline-position #'nano-modeline-footer)
  (nano-modeline-text-mode t))
#+end_src

I want to be able to unload this package in dark mode. Emacs provides a generic =unload-feature= function which can be configured further but defining a =FEATURE=unload-function=. We'll define this function because the generic unloading mostly just works on autoloaded functions and this package doesn't have any of those.

#+begin_src emacs-lisp
(defun nano-modeline-unload-function ()
  ;; Reset mode-line-format globally
  (setq-default mode-line-format (helpful--original-value 'mode-line-format))

  ;; Kill local mode-line-format in all buffers
  (dolist (buf (buffer-list))
    (with-current-buffer buf
      (kill-local-variable 'mode-line-format)))

  ;; Done — allow normal unload
  nil)
#+end_src

** OS Integration

Unfortunately fish is not POSIX compliant.

#+BEGIN_SRC emacs-lisp
(setq shell-file-name (executable-find "bash"))
#+END_SRC

** Peformance Hacking

* core functionality
#+call: confpkg("core")

** editor
:PROPERTIES:
:ID:       5310f553-4074-4870-888c-95f86879fb69
:END:

*** editor settings

Enable relative line numbers because it's a habit from vim

#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type 'relative)
#+END_SRC

Enable visual-line-mode globally by default and disable continuation fringe indicators.

#+begin_src emacs-lisp
(global-visual-line-mode 1)
(setq-default fringe-indicator-alist
              (cons '(continuation nil nil)
                    (assq-delete-all 'continuation fringe-indicator-alist)))
#+end_src

*** evil
#+call: confpkg(after="evil")

The ultimate convenience. We don't need to make any package declarations because we have the =:editor (evil +everywhere)= doom module enabled.

**** evil settings

This enables precise undo steps.

#+begin_src emacs-lisp
(setq evil-want-fine-undo t) ;; precise undo steps
#+end_src

**** evil-escape

I have no clue why this is enabled by default

#+begin_src emacs-lisp :tangle "packages.el"
(package! evil-escape :disable t)
#+end_src

**** hardtime.el

Let's make my programming tunnel vision even worse.

#+begin_src emacs-lisp :tangle "packages.el"
(package! hardtime
  :recipe (:host github
           :repo "ichernyshovvv/hardtime.el"
           :branch "master"))
#+end_src

#+begin_src emacs-lisp
(use-package! hardtime
  :config
  (defun evil-hardtime-check-command ()
    "Return non-nil if the currently executed command should be checked."
    (memq this-command '( next-line previous-line evil-previous-visual-line
                          right-char left-char left-word right-word
                          evil-forward-char evil-backward-char
                          evil-next-line evil-previous-line)))
  :custom
  (hardtime-predicate #'evil-hardtime-check-command)
  :commands hardtime-mode
  :init
  (dolist (hook '(prog-mode-hook org-agenda-mode-hook org-mode-hook))
           (add-hook hook #'hardtime-mode)))
#+end_src

*** navigation

**** keybindings
#+call: confpkg(after="evil")

I think flipping this makes a lot sense and they should merge this to vim bindings.

#+BEGIN_SRC emacs-lisp
(map! :map override-global-map
      :m "H" #'evil-beginning-of-visual-line
      :m "L" #'evil-end-of-visual-line
      :m "0" #'evil-beginning-of-line
      :m "$" #'evil-end-of-line)
#+END_SRC

Make working with wrapped lines easy

#+BEGIN_SRC emacs-lisp
(map!  :nv "j" #'evil-next-visual-line
       :nv "k" #'evil-previous-visual-line)
#+END_SRC

**** evil-snipe
#+call: confpkg(after="evil-snipe")

I don't want to spam j's and k's anymore

#+BEGIN_SRC emacs-lisp
(setq evil-snipe-smart-case t
      evil-snipe-scope 'visible)
#+END_SRC


*** completion

** window management

*** window splits

I find symbolic keybinds to be more intuitive, so let's add them for window split creation.

#+BEGIN_SRC emacs-lisp
(map! :leader
      "-" #'evil-window-split
      "|" #'evil-window-vsplit)
#+END_SRC

**** split prompt

Ask what buffer to switch to after making a new window split because it's a common operation I do.

First make newly-split window the active window

#+BEGIN_SRC emacs-lisp
(setq evil-split-window-below t
      evil-vsplit-window-right t)
#+END_SRC

Then, show a buffer prompt

#+BEGIN_SRC emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+END_SRC

*** layout rotation

Ever have fullscreen emacs with a nice vsplit going? Me? All the time. But since I run a tiling WM, minimizing to a half-screen emacs happens all the time too. Now a vsplit looks hideous and we need to switch layout to a regular hsplit.

This will be my relief.
#+begin_src emacs-lisp :tangle "packages.el"
(package! rotate)
#+end_src

Let's stash layout rotation under SPC w SPC, inspired by Tmux's use of C-b SPC to rotate windows.

 #+BEGIN_SRC emacs-lisp
(use-package! rotate
  :commands #'rotate-layout
  :init
  (map! :map evil-window-map
        "SPC" #'rotate-layout))
 #+END_SRC

** file management

Bind "<leader>ff" to switch to src/header pair replacing the find-file offered by doom. This is okay because "<leader>." does finding files for me.

#+BEGIN_SRC emacs-lisp
(map! :leader :desc "Find other file" "f f" #'ff-find-other-file)
#+END_SRC

* language configuration

** lsp & syntax-highlight
#+call: confpkg("lsp")

*** eglot-booster
:PROPERTIES:
:ID:       7af01b58-d326-464e-94a8-bcaf1f3b3fe5
:END:

#+begin_src emacs-lisp :tangle "packages.el"
(package! eglot-booster
  :recipe (:host github
           :repo "jdtsmith/eglot-booster"))
#+end_src

Configures eglot to use [[https://github.com/blahgeek/emacs-lsp-booster][lsp-booster]].

#+begin_src emacs-lisp
(use-package! eglot-booster
  :after eglot
  :config
  (setq eglot-booster-io-only t)) ;; emacs v30 introduced a faster JSON parser
#+end_src

*** jinx
:PROPERTIES:
:ID:       09cb9ebc-6e05-4ae6-8162-588f3146d051
:END:

Fast [[https://rrthomas.github.io/enchant/][enchant-based]] spell checker.

#+begin_src emacs-lisp :tangle "packages.el"
(package! jinx)
#+end_src

#+begin_src emacs-lisp
(use-package! jinx
  :commands jinx-mode
  :bind (("M-$" . jinx-correct)
         ("C-M-$" . jinx-languages))
  :init
  (dolist (hook '(typst-ts-mode-hook))
    (add-hook hook #'jinx-mode)))
#+end_src

** org
#+call: confpkg(after="org", pre="set-org-dir")

*** Installation

This declaration is from org-latex-preview

#+begin_src emacs-lisp :tangle "packages.el"
(package! org :recipe
  (:host nil :repo "https://git.tecosaur.net/mirrors/org-mode.git" :remote "mirror" :fork
         (:host nil :repo "https://git.tecosaur.net/tec/org-mode.git" :branch "dev" :remote "tecosaur")
         :files
         (:defaults "etc")
         :build t :pre-build
         (with-temp-file "org-version.el"
           (require 'lisp-mnt)
           (let
               ((version
                 (with-temp-buffer
                   (insert-file-contents "lisp/org.el")
                   (lm-header "version")))
                (git-version
                 (string-trim
                  (with-temp-buffer
                    (call-process "git" nil t nil "rev-parse" "--short" "HEAD")
                    (buffer-string)))))
             (insert
              (format "(defun org-release () \"The release version of Org.\" %S)\n" version)
              (format "(defun org-git-version () \"The truncate git commit hash of Org mode.\" %S)\n" git-version)
              "(provide 'org-version)\n"))))
  :pin nil)

(unpin! org)
#+end_src

*** Settings

Central directory for org relative paths to resolve from. This will also house both our project and zettelkasten directories.

#+name: set-org-dir
#+begin_src emacs-lisp
(setq org-directory "~/org")
#+end_src

Keep the final empty line of a subtree from being folded.

#+begin_src emacs-lisp
(setq org-cycle-separator-lines 1)
#+end_src

*** Aesthetics
#+call: confpkg(name="org-aesthetics", after="org")

**** Fonts

Set Roboto Mono as header font and resize headings.

#+BEGIN_SRC emacs-lisp
;; Resize Org headings
(dolist (face '((org-level-1 . 1.35)
                (org-level-2 . 1.3)
                (org-level-3 . 1.2)
                (org-level-4 . 1.1)
                (org-level-5 . 1.1)
                (org-level-6 . 1.1)
                (org-level-7 . 1.1)
                (org-level-8 . 1.1)))
  (set-face-attribute (car face) nil :family "Roboto Mono" :weight 'bold :height (cdr face)))

;; Make the document title a bit bigger
(set-face-attribute 'org-document-title nil :family "Roboto Mono" :weight 'bold :height 1.8)
#+END_SRC

**** Decluttering

Don't be a litterbug!

#+BEGIN_SRC emacs-lisp
(setq org-adapt-indentation t
      org-hide-leading-stars t
      org-hide-emphasis-markers t)  ;; hide markers(bold, italics, etc)
      ;; messes with cursor positions in cdlatex templates
      ;; org-pretty-entities t) ;; allow LaTeX-like syntax to insert special symbols
#+END_SRC

**** Source Blocks

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-edit-src-content-indentation 0)
#+END_SRC

*** Latex Previews

**** Load/Enable

Configure org-latex-preview to be load after org and enable auto-mode which reveals source text under the fragment being pointed to.

#+BEGIN_SRC emacs-lisp
(use-package! org-latex-preview
:after org
:hook (org-mode-hook . org-latex-preview-auto-mode)
#+END_SRC

**** Appearance Settings

Basic appearance settings.

#+BEGIN_SRC emacs-lisp
:config
;; enable latex-previews startup option
(setq org-startup-with-latex-preview t)

;; Increase preview width
(plist-put org-latex-preview-appearance-options
:page-width 1.0)
(plist-put org-latex-preview-appearance-options
:zoom 1.2)

;; enable consistent equation numbering
(setq org-latex-preview-numbered t)
#+END_SRC

**** Latency and Performance

#+BEGIN_SRC emacs-lisp
;; real time previews of latex fagments as you type
(setq org-latex-preview-live t)
(setq org-latex-preview-live-debounce 0.25)  ;; reducing delay before preview

;; png is faster than svg
(setq org-latex-preview-process-default 'dvipng)
)
#+END_SRC

*** Links
+Try to open arbitrary files in emacs+. Not needed anymore since org-link type =file+emacs= exists.
#+begin_src emacs-lisp
;; (add-to-list 'org-file-apps '(t . emacs))
#+end_src

Open web links in nyxt. I cannot set it to default on macOS because I haven't built the required .app package.
#+begin_src emacs-lisp
;; (setcdr (assoc "\\.x?html?\\'" org-file-apps) "")
#+end_src

*** exports
:PROPERTIES:
:ID:       e038c0dd-6188-43cd-af61-488024108f0c
:END:

Load the s5 backend from org-contrib

#+begin_src emacs-lisp
(add-to-list 'org-export-backends 's5)
#+end_src

** latex
#+call: confpkg()

I have enabled the =(latex +cdlatex)= doom module and will be configuring that module and auctex here.

*** Settings

Change latex-view to be in emacs(pdf-viewer)

#+begin_src emacs-lisp
(setq +latex-viewers '(pdf-tools))
(setq TeX-view-program-selection '((output-pdf "PDF Tools") (output-dvi "open") (output-html "open") (output-pdf "preview-pane")))
#+end_src

Make double quotes active again
#+begin_src emacs-lisp
(map! :map TeX-mode-map
      "\"" #'self-insert-command)
#+end_src

** vhdl
#+call: confpkg()

*** settings

#+begin_src emacs-lisp
(add-hook 'vhdl-mode-hook
          (lambda ()
            (setq indent-tabs-mode t)
            (setq tab-width 4)
            (setq vhdl-basic-offset 4)))
#+end_src

*** vhdl-mode

Use the latest version of =vhdl-mode=.

#+begin_src emacs-lisp
(use-package! vhdl-mode
  :load-path "~/.config/doom/emacs_packages/vhdl-mode-3.39.3")
#+end_src

*** vhdl-ext

#+begin_src emacs-lisp :tangle "packages.el"
(package! vhdl-ext)
#+end_src

Adds even more features to =vhdl-mode=

#+begin_src emacs-lisp
(use-package! vhdl-ext
  :hook (vhdl-mode-hook . vhdl-ext-mode)
  :init
  (setq vhdl-ext-feature-list
        '(font-lock
          xref
          capf
          hierarchy
          eglot
          ;; lsp
          ;; lsp-bridge
          ;; lspce
          flycheck
          beautify
          navigation
          template
          compilation
          imenu
          which-func
          hideshow
          ;; time-stamp
          ports
          ))
  :config
  (vhdl-ext-mode-setup)
  (add-to-list 'auto-mode-alist '("\\.vhdl?\\'" . vhdl-ts-mode))
  (vhdl-ext-flycheck-set-linter 'vhdl-ghdl)
  (vhdl-ext-eglot-set-server 've-rust-hdl)
#+end_src

Manual project management, we gotta do something about this

#+begin_src emacs-lisp
  (setq vhdl-ext-project-alist
        '(("single-cycle-rv32i"
           :root "/Users/abhijeetsurakanti/org/projects/comp-org/single-cycle-rv32i"
           :files ("src/ALU.vhd"
                   "src/RegFile.vhd"
                   "src/PC.vhd"
                   "src/Core.vhd"
                   "sim/Core_tb.vhdl")
           :workdir "library/work"
           )))
#+end_src

Some flycheck/linting configuration of ghdl

#+begin_src emacs-lisp
  (setq vhdl-ext-flycheck-use-open-buffers t)
  (setq-default flycheck-ghdl-language-standard "08")
  (setq vhdl-standard '(08 nil))
#+end_src

Close the =use-package!= paren

#+begin_src emacs-lisp
)
#+end_src

** web
#+call: confpkg()

*** templates

I have the =:editor file-templates= doom module enabled which configures file-templates (templates that expand automatically when entering empty files). I'd like to disable this specific [[file+emacs:~/dotfiles/emacs/dot-config/emacs/modules/editor/file-templates/templates/web-mode/__.html::<head>][file-template]].

#+begin_src emacs-lisp
(set-file-template! "\\.html$" :ignore t)
#+end_src

*** auto-reload

I want to work on my blog using only emacs as opposed to any npm dev packages. =impatient.el= is an emacs solution to auto-reloading page based on buffer changes. Obviously we still need a web-server which serves our html on localhost, that's where =simple-httpd= comes in.

#+begin_src emacs-lisp :tangle "packages.el"
(package! simple-httpd)
(package! impatient-mode)
#+end_src

#+begin_src emacs-lisp
(use-package! simple-httpd
  :bind (:map doom-leader-open-map
         ("w" . httpd-serve-directory)
         ("W" . httpd-stop)))
#+end_src

*** lsp
#+call: confpkg(name="web-lsp", after="eglot")

Web-mode does not have any registered lsp servers, so let's add one.

#+begin_src emacs-lisp
(add-to-list 'eglot-server-programs
             '(web-mode . ("vscode-html-language-server" "--stdio")))
#+end_src

** scheme
#+call: confpkg()

*** geiser

#+begin_src emacs-lisp :tangle "packages.el"
(package! geiser)
(package! geiser-mit)
#+end_src

#+begin_src emacs-lisp
(use-package! geiser
  :config
  (setq geiser-mit-binary "/usr/local/bin/scheme")
  (setq geiser-active-implementations '(mit)))
#+end_src

Here's the [[https://www.nongnu.org/geiser/Cheat-sheet.html#Cheat-sheet][cheatsheet]].


** typst
#+call: confpkg(needs="typst,tinymist")

The future of typesetting looks bright.

#+begin_src emacs-lisp :tangle "packages.el"
(package! typst-ts-mode
  :recipe (:type git
           :host codeberg
           :repo "meow_king/typst-ts-mode"))
#+end_src

Configure =typst-ts-preview-function= to open in emacs with pdf-view as a vsplit.

#+begin_src emacs-lisp
(use-package! typst-ts-mode
  :defer t
  :config
  (setq typst-ts-preview-function
      (lambda (file)
        (select-window (split-window-right))
        (find-file file)))
#+end_src

Setup [[id:09cb9ebc-6e05-4ae6-8162-588f3146d051][jinx]] integration.

#+begin_src emacs-lisp
(after! jinx
  (add-to-list
   'jinx-exclude-faces
   '(typst-ts-mode
     ;; not included font lock faces
     ;; `font-lock-comment-face', `font-lock-string-face', `font-lock-doc-face'
     ;; `font-lock-doc-markup-face'
     font-lock-warning-face font-lock-function-name-face font-lock-function-call-face
     font-lock-variable-name-face font-lock-variable-use-face font-lock-keyword-face
     font-lock-comment-delimiter-face font-lock-type-face font-lock-constant-face
     font-lock-builtin-face font-lock-preprocessor-face
     font-lock-negation-char-face font-lock-escape-face font-lock-number-face
     font-lock-operator-face font-lock-property-use-face font-lock-punctuation-face
     font-lock-bracket-face font-lock-delimiter-face font-lock-misc-punctuation-face
     ;; typst-ts-mode created faces
     typst-ts-markup-item-indicator-face typst-ts-markup-term-indicator-face
     typst-ts-markup-rawspan-indicator-face typst-ts-markup-rawspan-blob-face
     typst-ts-markup-rawblock-indicator-face typst-ts-markup-rawblock-lang-face
     typst-ts-markup-rawblock-blob-face
     typst-ts-error-face typst-ts-shorthand-face typst-ts-markup-linebreak-face
     typst-ts-markup-quote-face typst-ts-markup-url-face typst-ts-math-indicator-face)))
#+end_src

Add tinymist as an eglot-server-program for lsp.

#+begin_src emacs-lisp
(after! eglot
  (add-to-list 'eglot-server-programs
               `((typst-ts-mode) .
                 ,(eglot-alternatives `(,typst-ts-lsp-download-path
                                        "tinymist"
                                        "typst-lsp")))))
#+end_src

Close the =use-package!= paren

#+begin_src emacs-lisp
)
#+end_src


* tools & applications
#+call: confpkg()

** pdf-tools

Enable =auto-revert-mode= in =pdf-view-mode= and make it /fast/ by enabling revert on file notifications instead of polling.

#+begin_src emacs-lisp
(after! pdf-tools
  (add-hook 'pdf-view-mode-hook #'auto-revert-mode)
  (setq auto-revert-use-notify t))
#+end_src

** snippets
#+call: confpkg()

*** smartparens

I just want to disable a couple default pairs in latex math mode.

#+begin_src emacs-lisp
(sp-pair "(" ")" :unless '(sp-in-math-p))
(sp-pair "[" nil :unless '(sp-in-math-p))
(sp-pair "{" nil :unless '(sp-in-math-p))
#+end_src

*** laas
#+call: confpkg("org-laas")

=laas= is a set of LaTeX snippets built on =aas= that are designed to work efficiently with existing tools like =cdlatex=.

#+begin_src emacs-lisp :tangle "packages.el"
(package! laas)
#+end_src

I don't really make any proper latex documents, so I'm limiting my snippets to just org mode.

#+BEGIN_SRC emacs-lisp
(use-package! laas
  :hook (org-mode-hook . laas-mode)
  :config
  (aas-set-snippets 'laas-mode
#+END_SRC

**** org snippets

Useful snippets while working with the org files in general.

#+BEGIN_SRC emacs-lisp
"<src" '(yas "#+begin_src ${1:$$(yas-completing-read \"Language: \" (mapcar #'car org-babel-load-languages))}\n$0\n#+end_src")
#+END_SRC

**** latex environments

Environments auto-expanding snippets are under the ";e" prefix. Note that these involve only the commonly used envs, for anything else use =org-cdlatex-environment-indent=.

#+BEGIN_SRC emacs-lisp
";e" nil

";ee" '(yas "\\begin{$1}\n $0 \n\\end{$1}") ;; arbitrary environment
";ea" (lambda () (interactive) (insert "ali*") (cdlatex-tab)) ;; align*
";eq" (lambda () (interactive) (insert "equ") (cdlatex-tab)) ;; equation

;; TODO figure out how to get "M-RET" behavior for items
";ei" (lambda () (interactive) (insert "ite") (cdlatex-tab)) ;; itemize
";en" (lambda () (interactive) (insert "enu") (cdlatex-tab)) ;; enumerate

";es" (lambda () (interactive) (insert "sn") (cdlatex-tab)) ;; section
"sb" (lambda () (interactive) (insert "ss") (cdlatex-tab)) ;; subsection
"ssb" (lambda () (interactive) (insert "sss") (cdlatex-tab)) ;; subsubsection
 #+END_SRC

**** latex symbols

 Symbol expansions are handled by =cdlatex-math-symbol=, here we just set the prefix using laas.

 #+BEGIN_SRC emacs-lisp
";s" (lambda () (interactive) (cdlatex-math-symbol)) ;; symbols prefix
 #+END_SRC

**** latex entry

 Snippets to enter latex math mode. We start using yasnippet from now on because of the increased complexity, laas internall calls =yas-expand-snippet.=

 #+BEGIN_SRC emacs-lisp
;; (copied from karthink). We double escape '\' if we're preceding escapable chars
"mk" '(yas "\\\\( $1 \\\\)$0 ") ;; We're trying to pass the string "\\( $1 \\)$0"
"dm" '(yas "\\[ $1 \\]$0")
 #+END_SRC

**** latex commands

 Here we create math-only autosnippets for commonly used latex commands. We don't lump them all into a single prefix like we've been doing, intuitiveness takes precedence. Still I try to keep things under the ';' though.

 #+BEGIN_SRC emacs-lisp
:cond #'texmathp

;; general commands prefix
";c" nil
";ce" '(yas "\\left. $1 \\right|_{$2}$0")

;; calculus stuff
"lm" '(yas "\\\\lim_{${1:x} \\\\to ${2:\\\\infty}}$0")
"sm" '(yas "\\sum_{${1:i}={${2:0}}}^{${3:N}}$0")


;; integrals
";i" nil
";id" '(yas "\\\\int_{${1:-\\\\infty}}^{${2:\\\\infty}} $3~${0:dx}")
";in" '(yas "\\\\int $1~${0:dx}")
";2in" '(yas "\\\\iint $1~${0:dA}")
";3in" '(yas "\\\\iiint $1~${0:dV}")

;; derivatives
";d" nil
";di" '(yas "\\\\frac{\\\\mathrm{d}$1}{\\\\mathrm{d}${2:t}}$0")
";do" '(yas "\\\\frac{\\\\partial$1}{\\\\partial${2:t}}$0")
#+END_SRC

**** latex modifiers
:PROPERTIES:
:ID:       bc3e121d-99df-46de-ae39-c42004f2f3b8
:END:

Like symbols, most of them are implemented by =cdlatex=, we just make them more accessible by changing the prefix. Also note that =laas= also provides a few useful modifiers like the fraction and subscript handling which is sprinkled around.


#+BEGIN_SRC emacs-lisp
;; modifiers
";m" #'my/org-cdlatex-math-modify-snippet

";t" '(yas "^{$1}$0")
"_" '(yas "_{$1}$0")
"^" '(yas "^{$1}$0")

";v" '(yas "\\vec{$1}$0")
";q" '(yas "\\sqrt{$1}$0")

;; I've disabled smartparens in latex math mode
"(" '(yas "($1)$0")
"[" '(yas "[$1]$0")
";{" '(yas "\\\\{$1\\\\}$0")

";(" '(yas "\\left( $1 \\right)$0")
";[" '(yas "\\left[ $1 \\right]$0")
";|" '(yas "\\left| $1 \\right|$0")
#+END_SRC

**** misc

Close the use-package paren.
#+begin_src emacs-lisp
;;"[M-RET]" '(yas "\\\\\n &=$0")
))
#+end_src

Unbind =org-cdlatex-underscore-caret=

#+begin_src emacs-lisp
(map! :map org-cdlatex-mode-map
      "^" #'org-self-insert-command
      "_" #'org-self-insert-command
      )
#+end_src

This function adds a final '$0' tabstop to =org-cdlatex-math-modify= expansions.

#+begin_src emacs-lisp
(defun my/org-cdlatex-math-modify-snippet ()
  (interactive)
  (let ((start (point)))
    (org-cdlatex-math-modify)
    (let* ((end (point))
           (text (buffer-substring-no-properties start end)))
      (delete-region start end)
      (if (string-match "}" text)
        ;; Insert $1 before the last closing brace
        (setq text
              (replace-regexp-in-string
               "}" "$1}" text t t))
        (delete-region (point) (+ (point) 1))
        (setq text
              (concat text "$1}")))
      (yas-expand-snippet (concat text "$0")))))
#+end_src

** org extensions
#+call: confpkg("org-extensions")

*** Org-Superstar

#+begin_src emacs-lisp :tangle "packages.el"
(package! org-superstar)
#+end_src

#+BEGIN_SRC emacs-lisp
(use-package! org-superstar
  :hook (org-mode-hook . (lambda () (org-superstar-mode 1)))
  :after org
  :config
  (setq org-superstar-leading-bullet " "
        org-superstar-headline-bullets-list '("●" "○" "◆" "◇" "•" "⚬")
        org-superstar-item-bullet-alist '((42 . "⚬") (43 . "⚬") (45 . "⚬"))
        org-superstar-prettify-item-bullets t)
  #+END_SRC

Plain-list bullets are invisible because they have the org-indent face. We can make them visible by having them inherit the default face.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'org-list-dt nil :inherit 'default))
#+END_SRC

*** evil-tex

Provides useful text objects, movements, etc for LaTeX editing.
#+BEGIN_SRC emacs-lisp
(use-package! evil-tex
:hook (org-mode-hook . evil-tex-mode))
#+END_SRC

*** org-cdlatex
#+call: confpkg("cdlatex")

Org-cdlatex is the foundation to editing latex in org-mode. It removes much of the hassle of defining common latex macros and templates. Doing this with a snippet engine would've been pretty boring, so now we can just focus on adding more complex snippets like the auto-expanding ones to our snippet engine of choice: =aas=.

Change the symbol/modifier cycling key to ';'. Note for some reason these don't change the existing activating keymap bind; we do this later with =aas= though.

#+BEGIN_SRC emacs-lisp
(after! cdlatex
  (setq cdlatex-math-symbol-prefix ?\;)
  (setq cdlatex-math-modify-prefix ?\;)

  (map! :map cdlatex-mode-map
        "'" nil)
  (map! :map cdlatex-mode-map
        "`" nil)
#+END_SRC

Add custom environment snippets

#+BEGIN_SRC emacs-lisp
  (setq cdlatex-env-alist
        '(("bmatrix" "\\begin{bmatrix}\n?\n\\end{bmatrix}" nil)
          ("equation*" "\\begin{equation*}\n?\n\\end{equation*}" nil)))
#+END_SRC

Modify available symbols and modifiers

#+BEGIN_SRC emacs-lisp
   (setq cdlatex-math-symbol-alist
   '( ;; adding missing functions to 3rd level symbols
     (?_    ("\\downarrow"  ""           "\\inf"))
     (?2    ("^2"           "\\sqrt{?}"     ""     ))
     (?3    ("^3"           "\\sqrt[3]{?}"  ""     ))
     (?^    ("\\uparrow"    ""           "\\sup"))
     (?k    ("\\kappa"      ""           "\\ker"))
     (?m    ("\\mu"         ""           "\\lim"))
     (?c    (""             "\\circ"     "\\cos"))
     (?d    ("\\delta"      "\\partial"  "\\dim"))
     (?D    ("\\Delta"      "\\nabla"    "\\deg"))
     ;; no idea why \Phi isnt on 'F' in first place, \phi is on 'f'.
     (?F    ("\\Phi"))
     ;; now just convenience
     (?.    ("\\cdot " "\\dots "))
     (?:    ("\\vdots " "\\ddots "))
     (?*    ("\\cdot " "\\times " "\\star ")))

   cdlatex-math-modify-alist
   '( ;; adding modifiers
     (?B    "\\mathbb"        nil          t    nil  nil)
     (?a    "\\abs"           nil          t    nil  nil))))
#+END_SRC

**** Keybind hacks

I wanted to replace =indent-for-tab-command= with =cdlatex-tab= in the cdlatex contexts which is usually everywhere in an org file outside of snippets and source blocks. You'll often run through your snippets but still have to navigate the math, this is where having =cdlatex-tab= always available becomes massively useful.

#+begin_src emacs-lisp
(defun my/org-cdlatex-tab ()
  (interactive)
  (cond
   ;; Inside a snippet → yasnippet takes priority
   ((and (bound-and-true-p yas-minor-mode)
         (yas-active-snippets))
    (yas-next-field-or-maybe-expand))

   ;; Inside a source block → use default tab behavior
   ((org-in-src-block-p)
    (indent-for-tab-command))

   ;; Else → use cdlatex
   (t
    (cdlatex-tab))))
#+end_src

Add the binding to insert-state with cdlatex minor mode map for decent precedence. Note you can still use TAB's default behavior(indent-for-tab-command) by hitting "C-i" if you need to.

#+BEGIN_SRC emacs-lisp
(map! :map cdlatex-mode-map
      :i "<tab>" #'my/org-cdlatex-tab)
#+END_SRC

Rebind conflicting corfu's =[tab]= binding to =[M-tab]=. I don't use it much because the completion popup usually opens automatically.

#+BEGIN_SRC emacs-lisp
(map! :map corfu-map
      :i [tab] nil
      :i [m-tab] #'completion-at-point)
#+END_SRC

*** org-pdftools

This package comes in handy for custom org link types, but pdf links weren't working because the package makes depracated calls. A minor patch was made and here I've updated where the package is fetched from to my fork.

#+begin_src emacs-lisp :tangle "packages.el"
(package! org-pdftools
  :recipe (:fork (:repo "ekattsim/org-pdftools"
                  :branch "update-depracated-cl_calls")))

(unpin! org-pdftools)
#+end_src

*** Roam

Installed and pre-configured as part of the =:lang org +roam2= doom module.

Make "~/org/zettelkasten" the org-roam directory. Make sure only roam nodes are present in this directory.
#+BEGIN_SRC emacs-lisp
(setq org-roam-directory "/Users/abhijeetsurakanti/org/zettelkasten")
#+END_SRC

*** edraw

Brings the possiblity of hand-drawn notes into org mode. Hopefully I'll stop consuming so many notebooks with this.

#+begin_src emacs-lisp :tangle "packages.el"
(package! edraw
  :recipe (:host github
           :repo "misohena/el-easydraw"))
#+end_src

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (require 'edraw-org)
  (edraw-org-setup-exporter))
#+end_src

When exporting asynchronously with =org-export-in-background=, the instantiated emacs process only loads ox and not org. So let's load it after ox.el as well.

#+begin_src emacs-lisp
(with-eval-after-load "ox"
  (require 'edraw-org)
  (edraw-org-setup-exporter))
#+end_src

** rss feeds

#+begin_src emacs-lisp
(use-package! elfeed
  :config
  (setq elfeed-feeds
        '("https://xkcd.com/rss.xml"
          "https://hnrss.org/frontpage"
          "https://old.reddit.com/r/slatestarcodex.rss"
          "https://old.reddit.com/r/hardware.rss")))
#+end_src

** tramp
#+call: confpkg(after="tramp")

Some optimizations from [[https://www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html][tramp FAQ]]

#+begin_src emacs-lisp
(setq remote-file-name-inhibit-cache nil)
(setq vc-ignore-dir-regexp
      (format "%s\\|%s"
                    vc-ignore-dir-regexp
                    tramp-file-name-regexp))
(setq remote-file-name-inhibit-locks t)

(setq tramp-verbose 1)
#+end_src

** magit

Configure magit to use newer homebrew version of git instead of Apple Git.

#+begin_src emacs-lisp
(after! magit
  (setq magit-git-executable "/usr/local/bin/git"))
#+end_src

** mindstream
:PROPERTIES:
:ID:       0c4061a2-6486-43a5-bdc2-43aa269ffa32
:END:

#+begin_src emacs-lisp :tangle "packages.el"
(package! mindstream)
#+end_src

#+begin_src emacs-lisp
(use-package mindstream
  :config
  (mindstream-mode)
  (setq mindstream-template-path "/Users/abhijeetsurakanti/mindstream/templates")
#+end_src

idk if i prefer manual archiving but I sure as shit don't want to lose sessions to restarts or new sessions.

#+begin_src emacs-lisp
(setq mindstream-persist t
      mindstream-unique nil))
#+end_src

* personal workflow
#+call: confpkg()

** dashboard

Doom has a minimal dashboard that helps with startup times. Let's add a clean custom banner as well.

#+begin_src emacs-lisp
(setq fancy-splash-image "~/.config/doom/misc/splash-images/emacs-e-template.svg")
#+end_src

** projects
#+call: confpkg()

Create the =org-project-directory= with project files being any org files in this directory or one level below.

#+begin_src emacs-lisp
(defvar org-project-directory (expand-file-name "projects" org-directory))

(defun my/one-level-down-predicate (file)
  (let ((parent (file-name-directory file)))
    (string-equal (directory-file-name parent)
                  org-project-directory)))

(defun my/discover-project-files ()
  (directory-files-recursively org-project-directory
                               org-agenda-file-regexp
                               nil
                               #'my/one-level-down-predicate))

(defvar org-project-files (my/discover-project-files))

(use-package! projectile
  :init
  (setq projectile-project-search-path `((,org-project-directory . 1))))
#+end_src

Interactive browsing of project files under =org-project-directory= and its direct descendent directories.

#+begin_src emacs-lisp
(defun my/find-in-projects ()
  (interactive)
  (find-file
   (completing-read "Find project file: " org-project-files nil t)))

(map! :map doom-leader-notes-map
      "p" #'my/find-in-projects)
#+end_src

Creating a new project means creating a project directory under =org-project-directory= and adding a project file. Let's make an interactive command for this. Note that it also creates a ".projectile" file and adds it as a known projectile project.

#+begin_src emacs-lisp
(defun my/create-org-project ()
  "Create a new project directory under `org-project-directory` with a main Org file."
  (interactive)
  (let* ((project-name (read-string "Project name: "))
         (project-dir (expand-file-name project-name org-project-directory))
         (org-file (expand-file-name (concat project-name ".org") project-dir)))
    (if (file-exists-p project-dir)
        (user-error "Project '%s' already exists" project-name)
      (make-directory project-dir t)
      (write-region "" nil (expand-file-name ".project" project-dir))
      (projectile-add-known-project project-dir)
      (write-region (format-message "#+title: %s" project-name)
                    nil org-file)
      (find-file org-file)
      (message "Created project: %s" org-file))))
#+end_src

Let's add a file-watch that rebuilds =org-project-files= and =org-agenda-files on any changes in the =org-project-directory=.

#+begin_src emacs-lisp
(defun keep-projects-in-sync (event)
  (let ((action (cadr event)))
    (when (memq action '(created deleted renamed))
      ;; Refresh org project files
      (setq org-project-files (my/discover-project-files))

      ;; Refresh org agenda files
      (setq org-agenda-files
            (append (list +org-capture-todo-file
                          org-roam-directory
                          (expand-file-name "config.org" doom-user-dir))
                    org-project-files))
      )))

(require 'filenotify)
(file-notify-add-watch org-project-directory
                       '(change attribute-change)
                       #'keep-projects-in-sync)
#+end_src

** agenda
#+call: confpkg(after="org-agenda")

Take a look at [[id:9edd2c6e-2950-4689-b2e8-3c283297cd71][A new way of organization]]. In this section we'll mostly focus on the projects.

*** Setup

Let's change the location of the TODOs inbox to be in the org-directory.

#+begin_src emacs-lisp
(setq +org-capture-todo-file (expand-file-name "inbox.org" org-directory))
#+end_src

Hopefully these will be the only locations with TODO items.

 #+begin_src emacs-lisp
(setq org-agenda-files (list +org-capture-todo-file
                             org-roam-directory
                             (expand-file-name "config.org" doom-user-dir)))
#+end_src

I want my project directory to be searched recursively when looking for org agenda files.

#+begin_src emacs-lisp
(setq org-agenda-files (append org-agenda-files
                               org-project-files))
#+end_src

Make sure that all org headings with backlinks also have an ID property. This is useful because heading titles can change but ids don't usually.

#+begin_src emacs-lisp
(setq org-id-link-to-org-use-id t)
#+end_src

*** Misc

I need a function that can refile org-heading at point to a new a file. I'll be using this on my existing todo headings to link them to their project files.

#+begin_src emacs-lisp
(defun my/org-heading-to-project-file ()
  "Cut the current Org heading and its subtree, and paste it into a new project file.
The project file name is derived from the heading title and saved in `org-project-directory`.
Prompts for overwrite if the target file already exists."
  (interactive)
  (unless (org-at-heading-p)
    (user-error "Not at an Org heading"))

  ;; generate project-file path from heading-title
  (let* ((heading-title (org-get-heading t t t t))
         (sanitized-title (replace-regexp-in-string "[/?<>\\:*|\"&]" "_" heading-title))
         (project-file (expand-file-name (concat sanitized-title ".org")
                                         (or org-project-directory org-directory))))

    ;; Ask to confirm overwrite if file exists
    (if (and (file-exists-p project-file)
             (not (y-or-n-p (format "File '%s' already exists. Overwrite?" (file-name-nondirectory project-file)))))
        (user-error "Operation cancelled.")
      (progn
        ;; cut subtree from current buffer
        (org-back-to-heading t)
        (org-cut-subtree)

        ;; paste subtree
        (find-file project-file)
        (yank)

        ;; promote subtree until top-level
        (goto-char (point-min))
        (while (> (org-outline-level) 1)
          (org-promote-subtree))

        ;; save project-file
        (save-buffer)
        (message "Org heading moved to '%s'" project-file))
      )))
#+end_src


Disable visual-line-mode in agenda, it formats the tags on the next line and looks very bad.

#+begin_src emacs-lisp
(add-hook 'org-agenda-mode-hook
          (lambda ()
            (visual-line-mode 0)))
#+end_src

Bind rescheduling functions to =M-h= and =M-l=. So according to evil, we are in a motion state when browsing in agenda.

#+begin_src emacs-lisp
(map! :map org-agenda-mode-map
      :m "M-h" #'org-agenda-do-date-earlier
      :m "M-l" #'org-agenda-do-date-later)
#+end_src

*** Archiving

Set archive location, most likely only used on project files.

#+begin_src emacs-lisp
(setq org-archive-location (concat org-project-directory "/archives/%s_archive::"))
#+end_src

**** TODO interactive archive
SCHEDULED: <2025-08-18 Mon>

Interactive command to archive projects. Should be able to provide directories as well.

#+begin_src emacs-lisp
(defun my/archive-file (file &optional archive-dir)
  (let* ((new-file (if archive-dir
                       (concat org-project-directory
                               "/archives/"
                               (file-name-nondirectory file)
                               "_archive")
                     (concat file "_archive"))))
    (rename-file file new-file 1)
    (with-temp-buffer
      (insert "# -*- mode: org -*-\n\n")
      (insert-file-contents new-file)
      (write-region (point-min) (point-max) new-file))))

(defun my/archive-project ()
  (interactive)
  (let* ((project (completing-read "Archive project file: "
                                   org-project-files nil t))
         (project-parent (directory-file-name (file-name-directory project))))
    (if (string= project-parent
                 org-project-directory)
        ;; if project file
        (my/archive-file project t)
      ;; if file is in a project dir
      (let* ((project-name (file-name-nondirectory project-parent)))
        ;; archive all org files in project dir
        (mapc #'my/archive-file
              (directory-files-recursively project-parent
                                           org-agenda-file-regexp))
        ;; move to archive folder
        (rename-file project-parent
                     (concat org-project-directory
                             "/archives/"
                             project-name
                             "/"))))))
#+end_src

*** Workflow and Agenda view

Let's define the fundamental action cycle.

#+begin_src emacs-lisp
(setq org-todo-keywords '((sequence "TODO(t)" "INBOX(I)" "NEXT(n)" "WAIT(w)" "IDEA(i)" "|" "DONE(d)" "KILL(k)")))

;; Customized view for the daily workflow.
(setq org-agenda-custom-commands
  '(("n" "Agenday / NEXT / INBOX / WAIT / IDEA"
     ((agenda "" nil)
      (todo "INBOX" ((org-agenda-prefix-format '((todo . " %i %c: %-17?(org-entry-get nil \"CREATED\")")))))
      (todo "NEXT" nil)
      (todo "WAIT" nil)
      (todo "IDEA" nil))
     nil)))
#+end_src

Show the daily agenda by default. Also known as agenday, that's gonna catch on.

#+begin_src emacs-lisp
(setq org-agenda-span 'day
   org-agenda-start-on-weekday nil
   org-agenda-start-day nil)
#+end_src

Shorten deadline reminders to 2d by default. 2 weeks prior warnings is too much org-mode.

#+begin_src emacs-lisp
(setq org-deadline-warning-days 2)
#+end_src

In this workflow all TODOs have to be scheduled, so let's add an advice over the =org-todo= and =org-agenda-todo= functions.

#+begin_src emacs-lisp
(defadvice! schedule-after-todo (_arg)
  :after '(org-todo org-agenda-todo)
  (when (and (equal (org-get-todo-state) "TODO")
             (not (org-get-scheduled-time (point))))
    (org-schedule nil)))
#+end_src

*** Capture TODOs
#+call: confpkg(name="org-capture", after=["org"])

The workflow in my mind is that you would capture random TODOs to an inbox which you could then refile later with org-agenda. The capture mechanism is already implemented by [[file:~/dotfiles/emacs/dot-config/emacs/modules/lang/org/config.el::'(("t" "Personal todo" entry][doom's org module]], but there are a few changes I want to make.

Now let's make some changes to the default templates like todo template's description and removing the notes template since that is handled by roam.
#+begin_src emacs-lisp
(setq org-capture-templates
      (cons '("t" "todo" entry (file+headline +org-capture-todo-file "Inbox")
              "* INBOX %?\n:PROPERTIES:\n:CREATED: %u\n:END:" :prepend t)
            (cddr org-capture-templates)))
#+end_src

*** add dependency support for WAIT items

Some WAIT items are blocked because they are waiting for other tasks to be done first. In practice this means that you have to manually keep track of these dependencies like figuring out which WAIT item to put into the NEXT pile after completing a dependency TODO item.

We can automate this by allowing WAIT items to store a dependency list of items. When all of the items in this list are DONE, the WAIT item automatically becomes a NEXT item making it available for us to work on it.

We could have a function that on a DONE hook checks if the DONE was a dependency. If it was then decrement the dependency count by one. Finally check if dependency count = 0, then change item's TODO keyword from WAIT item to NEXT.

#+begin_src emacs-lisp
(defun my/org-task-done-hook ()
  "When a task is marked DONE, check if it unblocks any WAIT tasks."
  (when (equal (org-get-todo-state) "DONE")
    (let ((done-id (org-id-get nil t)))
      (if done-id
          (progn
            (print! "DONE ID value: %s" done-id)
            (my/org-update-dependent-tasks done-id))
        (print! "DONE ID is nil")))))

(defun my/org-update-dependent-tasks (done-id)
  "Update all WAIT tasks that list DONE-ID as a dependency."
  (org-map-entries
   (lambda ()
     (let ((deps-str (org-entry-get (point) "Dependencies")))
       (when (and deps-str (not (string-empty-p deps-str)))
         (let ((new-deps (remove-org-id-link-from-deps deps-str done-id)))
           (org-set-property "Dependencies" new-deps)
           (when (string-empty-p new-deps)
             (org-todo "NEXT"))))))
   "/+WAIT" 'agenda))

(defun remove-org-id-link-from-deps (deps-str done-id)
  "Remove the Org link with DONE-ID from DEPS-STR and trim excess whitespace."
  (string-trim
   (replace-regexp-in-string
    (format "\\[\\[id:%s\\]\\[.*?\\]\\][[:space:]]*" (regexp-quote done-id))
    ""
    deps-str)))

;; (add-hook 'org-after-todo-state-change-hook #'my/org-task-done-hook)
(defadvice! my/update-dependencies-after-done (_arg)
  :after '(org-todo org-agenda-todo)
  (my/org-task-done-hook))
#+end_src

** workspace management

Bind workspace navigation to be more like t-smart
#+BEGIN_SRC emacs-lisp
(map! :map override-global-map
      :g "C-t" #'+workspace/switch-to
      :g [C-tab] #'+workspace/other)
#+END_SRC

I love the scratch buffer. Let's test out an org major mode scratch.

#+begin_src emacs-lisp
(setq initial-major-mode 'org-mode)
#+end_src

** blog

*** exporting (ox-tufte)
:PROPERTIES:
:ID:       4ae88203-9360-41d5-a54c-0a3059125235
:END:

The first thing to do is getting org to export some decent looking webpages. Org's default stylesheet spits out something like this [[https://motherfuckingwebsite.com/][motherfucking website]]. I was actually quite excited about this until I found a [[http://bettermotherfuckingwebsite.com/][better motherfucking website]].

And when we take this to its logical extreme, we discover the pinnacle of web article styling: [[https://edwardtufte.github.io/tufte-css/][Tufte CSS]]. Contrary to the name, Tufte CSS also makes many demands of the HTML structure which means we'll have to modify/enhance the default ox-html backend. [[https://github.com/ox-tufte/ox-tufte?tab=readme-ov-file][ox-tufte]] does exactly this.

#+begin_src emacs-lisp :tangle "packages.el"
(package! ox-tufte)
#+end_src

#+begin_src emacs-lisp
(use-package! ox-tufte
  :config
  (setq org-html-htmlize-output-type 'css))
#+end_src

I can't for the life of me figure out how to set the =html_head= option for ox-html from emacs-lisp. I'll just set the keyword in the SETUPFILE.org which I'll then load with the =SETUPFILE= in-buffer setting.

#+begin_src org :tangle "misc/SETUPFILE.org"
#+HTML_HEAD: <link rel="stylesheet" href="/Users/abhijeetsurakanti/dotfiles/emacs/dot-config/doom/misc/tufte.css">
#+HTML_HEAD: <link rel="stylesheet" href="/Users/abhijeetsurakanti/dotfiles/emacs/dot-config/emacs/.local/straight/repos/ox-tufte/src/ox-tufte.css">
#+end_src

**** export settings
#+call: confpkg(after="org")

Disable automatic insertion of (sub/super)scripts.

#+begin_src emacs-lisp
(setq org-export-with-sub-superscripts nil)
#+end_src

*** publishing (org-publish)

** pomodoro
:PROPERTIES:
:ID:       f139bca0-09eb-4d67-9856-bc8ef6ecff95
:END:
#+call: confpkg()

#+begin_src emacs-lisp :tangle "packages.el"
(package! pomm)
#+end_src

#+begin_src emacs-lisp
(use-package! pomm
  :commands (pomm pomm-third-time)
  :bind (:map doom-leader-map
         ("P" . #'pomm))
  :config
  (setq pomm-audio-enabled t)
  (pomm-mode-line-mode)
#+end_src

And for integration with =org-clock=. I also like the idea of deferring clock-in until after some command to show that we're active.

#+begin_src emacs-lisp
  (setq pomm-org-clock-in-immediately nil)
  (add-hook 'pomm-on-status-changed-hook #'pomm--sync-org-clock)
  (add-hook 'pomm-third-time-on-status-changed-hook
            #'pomm-third-time--sync-org-clock)
#+end_src

Customize the alerts/sounds with culture.

#+begin_src emacs-lisp
  (setq pomm-audio-files '((work . "/Users/abhijeetsurakanti/.config/doom/misc/pomm-sounds/tuturu_1.mp3")
                           (tick . "/Users/abhijeetsurakanti/.config/doom/misc/pomm-sounds/osu-hit-sound.mp3")
                           (short-break . "/Users/abhijeetsurakanti/.config/doom/misc/pomm-sounds/to-be-continued.mp3")
                           (break . "/Users/abhijeetsurakanti/.config/doom/misc/pomm-sounds/to-be-continued.mp3")
                           (long-break . "/Users/abhijeetsurakanti/.config/doom/misc/pomm-sounds/to-be-continued.mp3")
                           (stop . "/Users/abhijeetsurakanti/.config/doom/misc/pomm-sounds/yamete-kudasai.mp3")))
#+end_src

#+begin_src emacs-lisp
)
#+end_src
