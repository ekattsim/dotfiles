:PROPERTIES:
:header-args:emacs-lisp: :results none :exports code
:END:

#+title: Config

* Introduction
This is my attempt at a literate configuration of doom emacs. [[*Confpkg]] is shamelessly lifted from [[https://tecosaur.github.io/emacs-config/config.html#doom-configuration][tecosaur's]] literate config.

* Confpkg
Clump parts of config into "self-contained packets of functionality".

** Design
It's already natural to organize blocks of config under sections, and we can use =:noweb-ref= with a =header-args:emacs-lisp= property to direct all child source blocks into a single parent. We could have two parents, one tangling to =subconf/config-X.el= and the other to =config.el=, however this will duplicate any evaluations required to generate the content, which isn't great (particularly for things which take a moment, like checking for LaTeX packages). Instead we can /just/ write to the =subconf/*= files and then at the end of tangling extract their contents into =config.el=.

To set this up within each section, instead of manually repeating a common form we can generate the form and supply the relevant section properties via a babel call keyword, like so:
#+begin_src org
,* Subject

,#+call: confpkg("subject")

,#+begin_src emacs-lisp
;; Code that configures the subject...
,#+end_src
#+end_src

** Preparation
This approach is built around =#+call= invocations that affect the tangling. Unfortunately for this use-case, babel call keywords are not executed on tangle. However, a *noweb ref* can be executed on tangle if we choose to expand its evaluation result instead of its body. And so we can fudge the behaviour we want by tangling a noweb ref to a temp file, where the referenced block(=confpkg-prepare=) executes all babel calls in the buffer.
#+name: confpkg-prepare
#+begin_src emacs-lisp :noweb no-export
(condition-case nil
    (progn
      (message "Intitialising confpkg")
      (org-fold-core-ignore-fragility-checks
        (org-babel-map-executables nil
          (when (eq (org-element-type (org-element-context)) 'babel-call)
            (org-babel-lob-execute-maybe)))))
  (quit (revert-buffer t t t)))
#+end_src

And here's the tangled noweb-ref that will execute =confpk-prepare=.
#+header: :tangle (expand-file-name (make-temp-name "emacs-org-babel-excuses/confpkg-prepare-") temporary-file-directory)
#+begin_src emacs-lisp :noweb no-export :mkdirp yes :export-embed no
<<confpkg-prepare()>>
#+end_src

** Setup
Before generating the template with babel, we want to keep track of:
+ How many config groups are created
+ Information about each config group

To do this we can simply create two variables. Due to temp-buffer shenanigans,
we'll have to use global variables here.

Then we need to set up the two final phases of this process:
+ Creating =config.el=
+ Cleaning up the superfluous generated content

To trigger the final phases we'll add a hook to ~org-babel-post-tangle-hook~. Once
again, it would be preferred if this was done locally, but it needs to be
global. To avoid this causing headaches down the line we'll make sure when
implementing the hook function to have it remove itself from the hook when
executed.
#+name: confpkg-setup
#+begin_src emacs-lisp :results silent :noweb no-export
(setq confpkg--num 0
      confpkg--list nil)

;; provide functions to be used in confpkg-tangle-finalize
<<confpkg-dependency-analysis>>
<<confpkg-strip-package-statements>>
<<confpkg-create-config>>
(defun confpkg-cleanup ()
 <<confpkg-cleanup>>
  )
<<confpkg-finalizer>>

;; executed right away and not just a function definition
<<confpkg-clear-old-files>>

(add-hook 'org-babel-tangle-finished-hook #'confpkg-tangle-finalize)
#+end_src

To avoid generating cruft, it would also be good to get rid of old tangled
config files at the start.
#+name: confpkg-clear-old-files
#+begin_src emacs-lisp
(make-directory "subconf" t)
(dolist (conf-file (directory-files "subconf" t "config-.*\\.el"))
  (delete-file conf-file))
#+end_src

Now to have this take effect, we can just use a babel call keyword. Thanks to
the preparation step this will be executed during tangling.
#+call: confpkg-setup[:results none]()

** Package generation
Now we actually implement the =confpkg= babel function. We could just direct the
output into the =subconf/config-X.el= file without any extra steps, but why not be
a bit fancier and make it more like a package.

To do this, we'll have =confpkg= load a template and then fill it in using
~format-spec~. To make sure this is actually used, we'll call ~org-set-property~ to
modify the parent heading, and register the config group with the variables we
created earlier.
#+name: confpkg
#+begin_src elisp :var name="" needs="" after="" pre="" prefix="config-" via="copy" emacs-minimum="29.1" :results raw :noweb no-export
;; Babel block for use with #+call
;; Arguments:
;;  - name, the name of the config sub-package
;;  - needs, (when non-empty) required system executable(s)
;;  - after, required features as a string or vector of strings
;;  - pre, a noweb reference to code that should be executed eagerly,
;;    and not deferred via after. The code is not included in the
;;    generated .el file and should only be used in dire situations.
;;  - prefix, the package prefix ("config-" by default)
;;  - via, how this configuration should be included in config.el,
;;    the current options are:
;;    + "copy", copy the configuration lisp
;;    + "require", insert a require statement
;;    + "none", do not do anything to load this configuration.
;;      This only makes sense when configuration is either being
;;      temporarily disabled or loaded indirectly/elsewhere.
;;  - emacs-minimum, the minimum emacs version ("29.1" by default)
(when (or (string-empty-p needs)
          (cl-every #'executable-find (delq nil (split-string needs ","))))
  (let* ((name (if (string-empty-p name)
                   (save-excursion
                     (and (org-back-to-heading-or-point-min t)
                          (substring-no-properties
                           (org-element-interpret-data
                            (org-element-property :title (org-element-at-point))))))
                 name))
         (after
          (cond
           ((and (stringp after) (string-empty-p after)) nil)
           ((and (stringp after) (string-match-p "\\`[^()]+\\'" after))
            (intern after)) ; Single feature.
           ((and (vectorp after) (cl-every #'stringp after))
            (nconc (list :and) (mapcar #'intern after)))
           (t nil)))
         (pre (and (not (string-empty-p pre)) pre))
         (confpkg-name
          (concat prefix (replace-regexp-in-string
                          "[^a-z-]" "-" (downcase name))))
         (confpkg-file (expand-file-name (concat confpkg-name ".el")
                                         "subconf")))
    (unless (file-exists-p confpkg-file)
      (make-empty-file confpkg-file t))
    (cl-incf confpkg--num)
    (org-set-property
     "header-args:emacs-lisp"
     (format ":tangle no :noweb-ref %s :noweb-sep \"\\n\\n\"" confpkg-name))
    (push (list :name name
                :package confpkg-name
                :file confpkg-file
                :after after
                :pre pre
                :via (intern via)
                :package-statements nil)
          confpkg--list)
    (format-spec
     "#+begin_src emacs-lisp :tangle %f :mkdirp yes :noweb no-export :noweb-ref none :comments no
<<confpkg-template>>
,#+end_src"
     `((?n . ,confpkg--num)
       (?p . ,confpkg-name)
       (?f . ,confpkg-file)
       (?e . ,emacs-minimum)
       (?Y . ,(format-time-string "%Y"))
       (?B . ,(format-time-string "%B"))
       (?m . ,(format-time-string "%m"))
       (?d . ,(format-time-string "%d"))
       (?M . ,(format-time-string "%M"))
       (?S . ,(format-time-string "%S"))))))
#+end_src

Now all that's needed is a template to be used.
#+name: confpkg-template
#+begin_src emacs-lisp :eval no
;;; %p.el --- Generated package (no.%n) from my config -*- lexical-binding: t; -*-
;;
;; Author: aesbetic
;; Maintainer: aesbetic
;; Created: %B %d, %Y
;; Modified: %B %d, %Y
;; Version: %Y.%m.%d
;; Homepage: https://github.com/ekattsim
;; Package-Requires: ((emacs \"%e\"))
;;
;; This file is not part of GNU Emacs.
;;
;;; Commentary:
;;
;;  Generated package (no.%n) from my config.
;;
;;  During generation, dependency on other aspects of my configuration and
;;  packages is inferred via (regexp-based) static analysis.  While this seems
;;  to do a good job, this method is imperfect.  This code likely depends on
;;  utilities provided by Doom, and if you try to run it in isolation you may
;;  discover the code makes more assumptions.
;;
;;  That said, I've found pretty good results so far.
;;
;;; Code:

<<%p>>

(provide '%p)
;;; %p.el ends here
#+end_src

This currently makes the included content look much more package-like than it
truly is.

Lastly, should there be an issue or interruption, it's possible that the
modifications from =#+call: confpkg= may persist. If I've been good with my
committing, resolving this should be as simple as reverting unstaged changes.
So... back in reality, it would be nice to have a way to clean up =confpkg=
residue.
#+name: confpkg-cleanup
#+begin_src emacs-lisp :results none
(org-fold-core-ignore-fragility-checks
  (org-babel-map-executables nil
    (when (and (eq (org-element-type (org-element-context)) 'babel-call)
               (equal (org-element-property :call (org-element-context)) "confpkg"))
      (org-babel-remove-result)
      (org-entry-delete nil "header-args:emacs-lisp"))))
#+end_src

** Identify cross-package dependencies
:PROPERTIES:
:header-args:emacs-lisp: :noweb-ref confpkg-dependency-analysis
:END:

At a basic level, we can search for regexp expressions indicating the definition
of functions or variables and search for their usage.

#+begin_src emacs-lisp
(defun confpkg--rough-extract-definitions (file)
  (with-temp-buffer
    (insert-file-contents file)
    (goto-char (point-min))
    (let (symbols)
      (while (re-search-forward
              (rx line-start (* (any ?\s ?\t)) "("
                  (or "defun" "defmacro" "defsubst" "defgeneric" "defalias" "defvar" "defcustom" "defface" "deftheme"
                      "cl-defun" "cl-defmacro" "cl-defsubst" "cl-defmethod" "cl-defstruct" "cl-defgeneric" "cl-deftype")
                  (+ (any ?\s ?\t))
                  (group (+ (any "A-Z" "a-z" "0-9"
                                 ?+ ?- ?* ?/ ?_ ?~ ?! ?@ ?$ ?% ?^ ?& ?= ?: ?< ?> ?{ ?})))
                  (or blank ?\n))
              nil t)
        (push (match-string 1) symbols))
      symbols)))
#+end_src

Continuing our rough regexp approach, we can construct a similar function to
look for uses of symbols.

#+begin_src emacs-lisp
(defun confpkg--rough-uses-p (file symbols)
  (with-temp-buffer
    (insert-file-contents file)
    (let ((symbols (copy-sequence symbols)) uses-p)
      (while symbols
        (goto-char (point-min))
        (if (re-search-forward (rx word-start (literal (car symbols)) word-end) nil t)
            (setq uses-p t symbols nil)
          (setq symbols (cdr symbols))))
      uses-p)))
#+end_src

Now we can put these two functions together to annotate ~confpkg--list~ with their
(confpkg) dependencies.

#+begin_src emacs-lisp
(defun confpkg-annotate-list-dependencies ()
  (dolist (confpkg confpkg--list)
    (plist-put confpkg :defines
               (confpkg--rough-extract-definitions
                (plist-get confpkg :file))))
  (dolist (confpkg confpkg--list)
    (let ((after (plist-get confpkg :after))
          requires)
      (dolist (other-confpkg confpkg--list)
        (when (and (not (eq other-confpkg confpkg))
                   (confpkg--rough-uses-p (plist-get confpkg :file)
                                          (plist-get other-confpkg :defines)))
          (push (plist-get other-confpkg :package) requires)))
      (when (and after (symbolp after))
        (push after requires))
      (plist-put confpkg :requires requires))))
#+end_src

Finally, we can use this information to edit the confpkg files to add the
necessary ~require~ statements.

#+begin_src emacs-lisp
(defun confpkg-write-dependencies ()
  (dolist (confpkg confpkg--list)
    (when (plist-get confpkg :requires)
      (with-temp-buffer
        (setq buffer-file-name (plist-get confpkg :file))
        (insert-file-contents buffer-file-name)
        (re-search-forward "^;;; Code:\n")
        (insert "\n")
        (dolist (req (plist-get confpkg :requires))
          (insert (format "(require '%s)\n" req)))
        (write-region nil nil buffer-file-name)
        (set-buffer-modified-p nil)))))
#+end_src

** Commenting out ~package!~ statements

It's easy enough to set ~package!~ statements to tangle to =packages.el=, however
with our noweb ref approach they will /also/ go to the config files. This could be
viewed as a problem, but I actually think it's rather nice to have the package
information with the config. So, we can look for an immediate ~package!~ statement
and simply comment it out. As a bonus, we can also then record which packages
are needed for each block of config.

#+name: confpkg-strip-package-statements
#+begin_src emacs-lisp
(defun confpkg-comment-out-package-statements ()
  (dolist (confpkg confpkg--list)
    (with-temp-buffer
      (setq buffer-file-name (plist-get confpkg :file))
      (insert-file-contents buffer-file-name)
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*(\\(package!\\|unpin!\\)[[:space:]\n]+\\([^[:space:]]+\\)\\b" nil t)
        (plist-put confpkg :package-statements
                   (nconc (plist-get confpkg :package-statements)
                          (list (match-string 2))))
        (let* ((start (progn (beginning-of-line) (point)))
               (end (progn (forward-sexp 1)
                           (if (looking-at "[\t ]*;.*")
                               (line-end-position)
                             (point))))
               (contents (buffer-substring start end))
               paste-start paste-end
               (comment-start ";")
               (comment-padding "   ")
               (comment-end ""))
          (delete-region start (1+ end))
          (re-search-backward "^;;; Code:")
          (beginning-of-line)
          (insert ";;  Package statement:\n")
          (setq paste-start (point))
          (insert contents)
          (setq paste-end (point))
          (insert  "\n;;\n")
          (comment-region paste-start paste-end 2)))
      (when (buffer-modified-p)
        (write-region nil nil buffer-file-name)
        (set-buffer-modified-p nil)))))
#+end_src

** Creating the config file

After all the subconfig files have been tangled, we need to collect their
content and put them together into =config.el=. For this, all that's needed is a
function to go through the registered config groups and put their content in a
tempbuffer. We can call this with the finalising step.

#+name: confpkg-create-config
#+begin_src emacs-lisp
(defun confpkg-create-config ()
  (let ((revert-without-query '("config\\.el"))
        (original-buffer (current-buffer)))
    (with-temp-buffer
      (insert
       (format ";;; config.el -*- lexical-binding: t; -*-

;; Generated at %s from the literate configuration.

(add-to-list 'load-path %S)\n"
               (format-time-string "%FT%T%z")
               (replace-regexp-in-string
                (regexp-quote (getenv "HOME")) "~"
                (expand-file-name "subconf/"))))
      (mapc
       (lambda (confpkg)
         (insert
          (if (eq 'none (plist-get confpkg :via))
              (format "\n;;; %s intentionally omitted.\n" (plist-get confpkg :name))
            (with-temp-buffer
              (cond
               ((eq 'copy (plist-get confpkg :via))
                (insert-file-contents (plist-get confpkg :file))
                (goto-char (point-min))
                (narrow-to-region
                 (re-search-forward "^;;; Code:\n+")
                 (progn
                   (goto-char (point-max))
                   (re-search-backward (format "[^\n\t ][\n\t ]*\n[\t ]*(provide '%s)" (plist-get confpkg :package)))
                   (match-end 0))))
               ((eq 'require (plist-get confpkg :via))
                (insert (format "(require '%s)\n" (plist-get confpkg :package))))
               (t (insert (format "(warn \"%s confpkg :via has unrecognised value: %S\" %S %S)"
                                  (plist-get confpkg :name) (plist-get confpkg :via)))))
              (goto-char (point-min))
              (insert "\n;;:------------------------"
                      "\n;;; " (plist-get confpkg :name)
                      "\n;;:------------------------\n\n")
              (when (plist-get confpkg :defines)
                (insert ";; This block defines "
                        (mapconcat
                         (lambda (d) (format "`%s'" d))
                         (plist-get confpkg :defines)
                         ", ")
                        ".")
                (when (re-search-backward "\\([^, ]+\\), \\([^, ]+\\), \\([^, ]+\\).\\="
                                          (line-beginning-position) t)
                  (replace-match "\\1, \\2, and \\3."))
                (when (re-search-backward "\\([^, ]+\\), \\([^, ]+\\).\\="
                                          (line-beginning-position) t)
                  (replace-match "\\1 and \\2."))
                (insert "\n\n")
                (forward-line -2)
                (setq-local comment-start ";")
                (fill-comment-paragraph)
                (forward-paragraph 1)
                (forward-line 1))
              (if (equal (plist-get confpkg :package) "config-confpkg-timings")
                  (progn
                    (goto-char (point-max))
                    (insert "\n\n\
(confpkg-create-record 'doom-pre-config (float-time (time-subtract (current-time) before-init-time)))
(confpkg-start-record 'config)
(confpkg-create-record 'config-defered 0.0 'config)
(confpkg-create-record 'set-hooks 0.0 'config-defered)
(confpkg-create-record 'load-hooks 0.0 'config-defered)
(confpkg-create-record 'requires 0.0 'root)\n"))
                (let ((after (plist-get confpkg :after))
                      (pre (and (plist-get confpkg :pre)
                                (org-babel-expand-noweb-references
                                 (list "emacs-lisp"
                                       (format "<<%s>>" (plist-get confpkg :pre))
                                       '((:noweb . "yes")
                                         (:comments . "none")))
                                 original-buffer)))
                      (name (replace-regexp-in-string
                             "config--?" ""
                             (plist-get confpkg :package))))
                  (if after
                      (insert (format "(confpkg-with-record '%S\n"
                                      (list (concat "hook: " name) 'set-hooks))
                              (if pre
                                  (concat ";; Begin pre\n" pre "\n;; End pre\n")
                                "")
                              (format (if (symbolp after) ; If single feature.
                                          "  (with-eval-after-load '%s\n"
                                        "  (after! %s\n")
                                      after))
                    (when pre
                      (insert "\n;; Begin pre (unnecesary since after is unused)\n"
                              pre
                              "\n;; End pre\n")))
                  (insert
                   (format "(confpkg-with-record '%S\n"
                           (list (concat "load: " name)
                                 (if after 'load-hooks 'config)))))
                (goto-char (point-max))
                (when (string-match-p ";" (thing-at-point 'line))
                  (insert "\n"))
                (insert ")")
                (when (plist-get confpkg :after)
                  (insert "))"))
                (insert "\n"))
              (buffer-string)))))
       (let ((confpkg-timings ;; Ensure timings is put first.
              (cl-some (lambda (p) (and (equal (plist-get p :package) "config-confpkg-timings") p))
                       confpkg--list)))
         (append (list confpkg-timings)
                 (nreverse (remove confpkg-timings confpkg--list)))))
      (insert "\n(confpkg-finish-record 'config)\n\n;;; config.el ends here")
      (write-region nil nil "config.el" nil :silent))))
#+end_src

Applying lexical binding to the config file is good for a number of reasons,
among which it's (slightly) faster than dynamic binding (see [[https://nullprogram.com/blog/2016/12/22/][this blog post]] for
more info).

** Quieter output

All the babel evaluation here ends up being quite noisy (along with a few other
things during tangle), let's see if we can change that.

#+name: confpkg-quieter-output
#+begin_src emacs-lisp
(when noninteractive
  (unless (fboundp 'doom-shut-up-a)
    (defun doom-shut-up-a (fn &rest args)
      (let ((standard-output #'ignore)
            (inhibit-message t))
        (apply fn args))))
  (advice-add 'org-babel-expand-body:emacs-lisp :around #'doom-shut-up-a)
  ;; Quiet some other annoying messages
  (advice-add 'sh-set-shell :around #'doom-shut-up-a)
  (advice-add 'rng-what-schema :around #'doom-shut-up-a)
  (advice-add 'python-indent-guess-indent-offset :around #'doom-shut-up-a))
#+end_src

#+call: confpkg-quieter-output()

** Reporting load time information

#+call: confpkg("Confpkg timings")

When generating the config we added a form to collect load-time information.

#+begin_src emacs-lisp
(defvar confpkg-load-time-tree (list (list 'root)))
(defvar confpkg-record-branch (list 'root))
(defvar confpkg-record-num 0)
#+end_src

It would be good to process ~confpkg-load-times~ at the end to make it more
useful, and provide a function to display load time information from it. This is
to aid in identification of confpkgs that take particularly long to load, and
thus would benefit from some attention.

To extract the per-confpkg load times, we can just take the difference in
~(float-time)~ and exclude the first entry.

#+begin_src emacs-lisp
(defun confpkg-create-record (name elapsed &optional parent enclosing)
  (let ((parent (assoc (or parent (car confpkg-record-branch))
                       confpkg-load-time-tree))
        (record (cons name (list (list 'self
                                       :name (format "%s" name)
                                       :num (cl-incf confpkg-record-num)
                                       :elapsed elapsed
                                       :enclosing enclosing)))))
    (push record confpkg-load-time-tree)
    (push record (cdr parent))
    record))

(defun confpkg-start-record (name &optional parent)
  (let ((record (confpkg-create-record name 0.0e+NaN parent t)))
    (plist-put (cdadr record) :start (float-time))
    (push name confpkg-record-branch)
    record))

(defun confpkg-finish-record (name)
  (let ((self-record (cdar (last (cdr (assoc name confpkg-load-time-tree))))))
    (plist-put self-record :elapsed
               (- (float-time) (plist-get self-record :start) 0.0))
    (unless (equal (car confpkg-record-branch) name)
      (message "Warning: Confpkg timing record expected to finish %S, instead found %S. %S"
               name (car confpkg-record-branch) confpkg-record-branch))
    (setq confpkg-record-branch (cdr confpkg-record-branch))))
#+end_src

A convenience macro could be nice to have.

#+begin_src emacs-lisp
(defmacro confpkg-with-record (name &rest body)
  "Create a time record around BODY.
The record must have a NAME."
  (declare (indent 1))
  (let ((name-val (make-symbol "name-val"))
        (record-spec (make-symbol "record-spec")))
    `(let* ((,name-val ,name)
            (,record-spec (if (consp ,name-val) ,name-val (list ,name-val))))
       (apply #'confpkg-start-record ,record-spec)
       (unwind-protect
           (progn ,@body)
         (confpkg-finish-record (car ,record-spec))))))
#+end_src

It would also be nice to collect some other load-time-related information.

#+begin_src emacs-lisp
(defadvice! +require--log-timing-a (orig-fn feature &optional filename noerror)
  :around #'require
  (if (or (featurep feature)
          (eq feature 'cus-start) ; HACK Why!?!
          (assoc (format "require: %s" feature) confpkg-load-time-tree))
      (funcall orig-fn feature filename noerror)
    (confpkg-with-record (list (format "require: %s" feature)
                               (and (eq (car confpkg-record-branch) 'root)
                                    'requires))
      (funcall orig-fn feature filename noerror))))
#+end_src

At last, we'll go to some pains to make a nice result tabulation function.

I will readily admit that this function is absolutely horrible. I just spent an
evening adding to it till it worked then stopped touching it. Maybe in the
future I'll go back to it and try to clean up the implementation.

#+begin_src emacs-lisp
(defun confpkg-timings-report (&optional sort-p node)
  "Display a report on load-time information.
Supply SORT-P (or the universal argument) to sort the results.
NODE defaults to the root node."
  (interactive
   (list (and current-prefix-arg t)))
  (let ((buf (get-buffer-create "*Confpkg Load Time Report*"))
        (depth 0)
        num-pad name-pad max-time max-total-time max-depth)
    (cl-labels
        ((sort-records-by-time
          (record)
          (let ((self (assoc 'self record)))
            (append (list self)
                    (sort (nreverse (remove self (cdr record)))
                          (lambda (a b)
                            (> (or (plist-get (alist-get 'self a) :total) 0.0)
                               (or (plist-get (alist-get 'self b) :total) 0.0)))))))
         (print-record
          (record)
          (cond
           ((eq (car record) 'self)
            (insert
             (propertize
              (string-pad (number-to-string (plist-get (cdr record) :num)) num-pad)
              'face 'font-lock-keyword-face)
             " "
             (propertize
              (apply #'concat
                     (make-list (1- depth) "• "))
              'face 'font-lock-comment-face)
             (string-pad (format "%s" (plist-get (cdr record) :name)) name-pad)
             (make-string (* (- max-depth depth) 2) ?\s)
             (propertize
              (format "%.4fs" (plist-get (cdr record) :elapsed))
              'face
              (list :foreground
                    (doom-blend 'orange 'green
                                (/ (plist-get (cdr record) :elapsed) max-time))))
             (if (= (plist-get (cdr record) :elapsed)
                    (plist-get (cdr record) :total))
                 ""
               (concat "   (Σ="
                       (propertize
                        (format "%.3fs" (plist-get (cdr record) :total))
                        'face
                        (list :foreground
                              (doom-blend 'orange 'green
                                          (/ (plist-get (cdr record) :total) max-total-time))))
                       ")"))
             "\n"))
           (t
            (cl-incf depth)
            (mapc
             #'print-record
             (if sort-p
                 (sort-records-by-time record)
               (reverse (cdr record))))
            (cl-decf depth))))
         (flatten-records
          (records)
          (if (eq (car records) 'self)
              (list records)
            (mapcan
             #'flatten-records
             (reverse (cdr records)))))
         (tree-depth
          (records &optional depth)
          (if (eq (car records) 'self)
              (or depth 0)
            (1+ (cl-reduce #'max (cdr records) :key #'tree-depth))))
         (mapreduceprop
          (list map reduce prop)
          (cl-reduce
           reduce list
           :key
           (lambda (p) (funcall map (plist-get (cdr p) prop)))))
         (elaborate-timings
          (record)
          (if (eq (car record) 'self)
              (plist-get (cdr record) :elapsed)
            (let ((total (cl-reduce #'+ (cdr record)
                                    :key #'elaborate-timings))
                  (self (cdr (assoc 'self record))))
              (if (plist-get self :enclosing)
                  (prog1
                      (plist-get self :elapsed)
                    (plist-put self :total (plist-get self :elapsed))
                    (plist-put self :elapsed
                               (- (* 2 (plist-get self :elapsed)) total)))
                (plist-put self :total total)
                total))))
         (elaborated-timings
          (record)
          (let ((record (copy-tree record)))
            (elaborate-timings record)
            record)))
      (let* ((tree
              (elaborated-timings
               (append '(root)
                       (copy-tree
                        (alist-get (or node 'root)
                                   confpkg-load-time-tree
                                   nil nil #'equal))
                       '((self :num 0 :elapsed 0)))))
             (flat-records
              (cl-remove-if
               (lambda (rec) (= (plist-get (cdr rec) :num) 0))
               (flatten-records tree))))
        (setq max-time (mapreduceprop flat-records #'identity #'max :elapsed)
              max-total-time (mapreduceprop flat-records #'identity #'max :total)
              name-pad (mapreduceprop flat-records #'length #'max :name)
              num-pad (mapreduceprop flat-records
                                     (lambda (n) (length (number-to-string n)))
                                     #'max :num)
              max-depth (tree-depth tree))
        (with-current-buffer buf
          (erase-buffer)
          (setq-local outline-regexp "[0-9]+ *\\(?:• \\)*")
          (outline-minor-mode 1)
          (use-local-map (make-sparse-keymap))
          (local-set-key "TAB" #'outline-toggle-children)
          (local-set-key "\t" #'outline-toggle-children)
          (local-set-key (kbd "<backtab>") #'outline-show-subtree)
          (local-set-key (kbd "C-<iso-lefttab>")
                         (eval `(cmd! (if current-prefix-arg
                                          (outline-show-all)
                                        (outline-hide-sublevels (+ ,num-pad 2))))))
          (insert
           (propertize
            (concat (string-pad "#" num-pad) " "
                    (string-pad "Confpkg"
                                (+ name-pad (* 2 max-depth) -3))
                    (format " Load Time (Σ=%.3fs)\n"
                            (plist-get (cdr (assoc 'self tree)) :total)))
            'face '(:inherit (tab-bar-tab bold) :extend t :underline t)))
          (dolist (record (if sort-p
                              (sort-records-by-time tree)
                            (reverse (cdr tree))))
            (unless (eq (car record) 'self)
              (print-record record)))
          (set-buffer-modified-p nil)
          (goto-char (point-min)))
        (pop-to-buffer buf)))))
#+end_src

** Finalize

At last, to clean up the content inserted by the babel calls we can just revert
the buffer. As long as ~org-babel-pre-tangle-hook~ hasn't been modified,
~save-buffer~ will be run at the start of the tangle process and so reverting will
take us back to just before the tangle started.

Since this is /the/ function added as the post-tangle hook, we also need to remove
the function from the hook and call the =config.el= creation function.

#+name: confpkg-finalizer
#+begin_src emacs-lisp
(defun confpkg-tangle-finalize ()
  (remove-hook 'org-babel-tangle-finished-hook #'confpkg-tangle-finalize)
  (revert-buffer t t t)
  (confpkg-comment-out-package-statements)
  (confpkg-annotate-list-dependencies)
  (confpkg-create-config)
  (confpkg-write-dependencies)
  (message "Processed %s elisp files" (length confpkg--list)))
#+end_src

Within ~confpkg-tangle-finalize~ we carefully order each step so that
the most important steps go first, to minimise the impact should a particular
step fail.

* General configuration
** Personal information
#+call: confpkg()
I'm not exactly sure where this information is used but here goes anyway.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Aesbetic"
      user-mail-address "aesbetic@gmail.com")
#+END_SRC

** System settings
#+call: confpkg("defaults")
Changes to core-emacs default behavior should be made here.

*** Simple settings
Small tweaks on top of defaults.
#+BEGIN_SRC emacs-lisp
(setq shell-file-name (executable-find "bash")) ;; fish is Non-POSIX unfortunately

#+END_SRC

*** Customize
Autoload the custom.el file if it exists.
#+BEGIN_SRC emacs-lisp
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

*** Frames
Remove the title bar because it's unaesthetic.
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(undecorated-round . t))
#+END_SRC

*** Windows
 #+call: confpkg()

**** Window operations
I find symbolic keybinds to be more intuitive, so let's add them for window split creation.
#+BEGIN_SRC emacs-lisp
(map! :leader
      "-" #'evil-window-split
      "|" #'evil-window-vsplit)
#+END_SRC

**** Layout Rotation
Ever have fullscreen emacs with a nice vsplit going? Me? All the time. But since I run a tiling WM, minimizing to a half-screen emacs happens all the time too. Now a vsplit looks hideous and we need to switch layout to a regular hsplit.

This will be my relief.
#+begin_src emacs-lisp :tangle "packages.el"
(package! rotate)
#+end_src

Let's stash layout rotation under SPC w SPC, inspired by Tmux's use of C-b SPC to rotate windows.
 #+BEGIN_SRC emacs-lisp
(use-package! rotate
  :commands #'rotate-layout
  :init
  (map! :map evil-window-map
        "SPC" #'rotate-layout)
  )
 #+END_SRC
**** Split prompt
#+call: confpkg(after="evil")

Ask what buffer to switch to after making a new window split because it's a common operation I do.

First make newly-split window the active window
#+BEGIN_SRC emacs-lisp
(setq evil-split-window-below t
      evil-vsplit-window-right t)
#+END_SRC

Then, show a buffer prompt
#+BEGIN_SRC emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+END_SRC

*** Files
Bind "<leader>ff" to switch to src/header pair replacing the find-file offered by doom. This is okay because "<leader>." does finding files for me.
#+BEGIN_SRC emacs-lisp
(map! :leader :desc "Find other file" "f f" #'ff-find-other-file)
#+END_SRC

** Doom configuration
#+call: confpkg("doom-config")
Changes to doom functionality should be made here.

*** Modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref none
:END:
Modules need to be declared in [[file:init.el][init.el]]. Doom comes with a lot of features so when you find some flashy new functionality, you should first check whether doom has a related module.

#+name: init.el
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :noweb-ref none
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :input
       <<doom-input>>

       :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src

**** Structure
Enable the =literate= module which tangles source blocks from =$DOOMDIR/config.org= to =config.el= on =doom sync=. There's also the =default= module which sets up default bindings, etc.

#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

**** Input
#+name: doom-input
#+begin_src emacs-lisp
;;bidi              ; (tfel ot) thgir etirw uoy gnipleh
;;chinese
;;japanese
;;layout            ; auie,ctsrnm is the superior home row
#+end_src

**** Interface
Group of doom modules that make up the emacs interface.

#+name: doom-completion
#+begin_src emacs-lisp
;;company           ; the ultimate code completion backend
(corfu +orderless)  ; complete with cap(f), cape and a flying feather!
;;helm              ; the *other* search engine for love and life
;;ido               ; the other *other* search engine...
;;ivy               ; a search engine for love and life
vertico           ; the search engine of the future
#+end_src

#+name: doom-ui
#+begin_src emacs-lisp
;;deft              ; notational velocity for Emacs
doom              ; what makes DOOM look the way it does
doom-dashboard    ; a nifty splash screen for Emacs
;;doom-quit         ; DOOM quit-message prompts when you quit Emacs
;;(emoji +unicode)  ; 🙂
hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
;;indent-guides     ; highlighted indent columns
;;ligatures         ; ligatures and symbols to make your code pretty again
;;minimap           ; show a map of the code on the side
;;modeline          ; snazzy, Atom-inspired modeline, plus API
;;nav-flash         ; blink cursor line after big motions
;;neotree           ; a project drawer, like NERDTree for vim
ophints           ; highlight the region an operation acts on
(popup +defaults)   ; tame sudden yet inevitable temporary windows
;;tabs              ; a tab bar for Emacs
;;treemacs          ; a project drawer, like neotree but cooler
;;unicode           ; extended unicode support for various languages
(vc-gutter +pretty) ; vcs diff in the fringe
vi-tilde-fringe   ; fringe tildes to mark beyond EOB
;;window-select     ; visually switch windows
workspaces        ; tab emulation, persistence & separate workspaces
zen               ; distraction-free coding or writing (TODO)
#+end_src

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere); come to the dark side, we have cookies
file-templates    ; auto-snippets for empty files
fold              ; (nigh) universal code folding
;;(format +onsave)  ; automated prettiness
;;god               ; run Emacs commands without modifier keys
;;lispy             ; vim for lisp, for people who don't like vim
;;multiple-cursors  ; editing in many places at once
;;objed             ; text object editing for the innocent
;;parinfer          ; turn lisp into python, sort of
;;rotate-text       ; cycle region at point between text candidates
snippets          ; my elves. They type so I don't have to
;;word-wrap         ; soft wrapping with language-aware indent
#+end_src

#+name: doom-emacs
#+begin_src emacs-lisp
dired             ; making dired pretty [functional]
electric          ; smarter, keyword-based electric-indent
;;eww               ; the internet is gross
;;ibuffer           ; interactive buffer management
undo              ; persistent, smarter undo for your inevitable mistakes
vc                ; version-control and Emacs, sitting in a tree
#+end_src

#+name: doom-term
#+begin_src emacs-lisp
;;eshell            ; the elisp shell that works everywhere
;;shell             ; simple shell REPL for Emacs
;;term              ; basic terminal emulator for Emacs
vterm             ; the best terminal emulation in Emacs
#+end_src

#+name: doom-checkers
#+begin_src emacs-lisp
syntax              ; tasing you for every semicolon you forget
;;(spell +flyspell) ; tasing you for misspelling mispelling
;;grammar           ; tasing grammar mistake every you make
#+end_src

#+name: doom-tools
#+begin_src emacs-lisp
;;ansible
;;biblio            ; Writes a PhD for you (citation needed)
;;collab            ; buffers with friends
;;debugger          ; FIXME stepping through code, to help you add bugs
;;direnv
;;docker
;;editorconfig      ; let someone else argue about tabs vs spaces
;;ein               ; tame Jupyter notebooks with emacs
(eval +overlay)     ; run code, run (also, repls)
lookup              ; navigate your code and its documentation
(lsp +eglot)               ; M-x vscode
magit             ; a git porcelain for Emacs
;;make              ; run make tasks from Emacs
;;pass              ; password manager for nerds
pdf               ; pdf enhancements
;;prodigy           ; FIXME managing external services & code builders
;;terraform         ; infrastructure as code
;;tmux              ; an API for interacting with tmux
;;tree-sitter       ; syntax and parsing, sitting in a tree...
;;upload            ; map local to remote projects via ssh/ftp
#+end_src

#+name: doom-os
#+begin_src emacs-lisp
(:if (featurep :system 'macos) macos)  ; improve compatibility with macOS
;;tty               ; improve the terminal Emacs experience
#+end_src

**** Language support
Language modules are lazy-loaded so we might as well enable all we want.
#+name: doom-lang
#+begin_src emacs-lisp
;;agda              ; types of types of types of types...
;;beancount         ; mind the GAAP
(cc +lsp)         ; C > C++ == 1
;;clojure           ; java with a lisp
;;common-lisp       ; if you've seen one lisp, you've seen them all
;;coq               ; proofs-as-programs
;;crystal           ; ruby at the speed of c
;;csharp            ; unity, .NET, and mono shenanigans
;;data              ; config/data formats
;;(dart +flutter)   ; paint ui and not much else
;;dhall
;;elixir            ; erlang done right
;;elm               ; care for a cup of TEA?
emacs-lisp        ; drown in parentheses
;;erlang            ; an elegant language for a more civilized age
;;ess               ; emacs speaks statistics
;;factor
;;faust             ; dsp, but you get to keep your soul
;;fortran           ; in FORTRAN, GOD is REAL (unless declared INTEGER)
;;fsharp            ; ML stands for Microsoft's Language
;;fstar             ; (dependent) types and (monadic) effects and Z3
;;gdscript          ; the language you waited for
;;(go +lsp)         ; the hipster dialect
;;(graphql +lsp)    ; Give queries a REST
;;(haskell +lsp)    ; a language that's lazier than I am
;;hy                ; readability of scheme w/ speed of python
;;idris             ; a language you can depend on
;;json              ; At least it ain't XML
;;(java +lsp)       ; the poster child for carpal tunnel syndrome
;;javascript        ; all(hope(abandon(ye(who(enter(here))))))
;;julia             ; a better, faster MATLAB
;;kotlin            ; a better, slicker Java(Script)
(latex +cdlatex)             ; writing papers in Emacs has never been so fun
;;lean              ; for folks with too much to prove
;;ledger            ; be audit you can be
lua               ; one-based indices? one-based indices
markdown          ; writing docs for people to ignore
;;nim               ; python + lisp at the speed of c
;;nix               ; I hereby declare "nix geht mehr!"
;;ocaml             ; an objective camel
(org +roam2)               ; organize your plain life in plain text
;;php               ; perl's insecure younger brother
;;plantuml          ; diagrams for confusing people more
;;graphviz          ; diagrams for confusing yourself even more
;;purescript        ; javascript, but functional
;;python            ; beautiful is better than ugly
;;qt                ; the 'cutest' gui framework ever
;;racket            ; a DSL for DSLs
;;raku              ; the artist formerly known as perl6
;;rest              ; Emacs as a REST client
;;rst               ; ReST in peace
;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
;;(rust +lsp)       ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala             ; java, but good
;;(scheme +guile)   ; a fully conniving family of lisps
sh                ; she sells {ba,z,fi}sh shells on the C xor
;;sml
;;solidity          ; do you need a blockchain? No.
;;swift             ; who asked for emoji variables?
;;terra             ; Earth and Moon in alignment for performance.
;;web               ; the tubes
;;yaml              ; JSON, but readable
;;zig               ; C, but simpler
#+end_src

**** Applications
#+name: doom-email
#+begin_src emacs-lisp
;;(mu4e +org +gmail)
;;notmuch
;;(wanderlust +gmail)
#+end_src

#+name: doom-app
#+begin_src emacs-lisp
;;calendar
;;emms
;;everywhere        ; *leave* Emacs!? You must be joking
;;irc               ; how neckbeards socialize
rss        ; emacs as an RSS reader
#+end_src

*** Doom UI
**** Theme
Load theme, taking current system appearance into consideration.
#+BEGIN_SRC emacs-lisp
(defun my/apply-theme (appearance)
  (mapc #'disable-theme custom-enabled-themes)
  (pcase appearance
    ('light (setq doom-theme 'tango)
            (load-theme 'tango t))
    ('dark (setq doom-theme 'doom-lantern)
           (load-theme 'doom-lantern t)))
  (load-file "~/.config/doom/subconf/config-org-aesthetics.el")) ;; first use of confpkg!!!

(add-hook 'ns-system-appearance-change-functions #'my/apply-theme)
#+END_SRC
*Note:* I might remove this if it gets dark outside too quick.

**** Fonts
Add Roboto Mono and Source Sans Pro as fixed and variable pitch fonts respectively.

#+BEGIN_SRC emacs-lisp
(when (member "Roboto Mono" (font-family-list))
  (setq doom-font (font-spec :family "Roboto Mono" :height 15.0)))
  ;; (set-face-attribute 'default nil :family "Roboto Mono" :height 150)
  ;; (set-face-attribute 'fixed-pitch nil :family "Roboto Mono"))

(when (member "Source Sans Pro" (font-family-list))
  ;; variable pitch font will be a little larger than fixed fonts
  (setq doom-variable-pitch-font (font-spec :family "Source Sans Pro" :size 18.0)))
  ;; (set-face-attribute 'variable-pitch nil :family "Source Sans Pro" :height 1.20))
#+END_SRC

*** Dashboard
Doom has a minimal dashboard that helps with startup times. Let's add a clean custom banner as well.
#+begin_src emacs-lisp
(setq fancy-splash-image "~/.config/doom/misc/splash-images/emacs-e-template.svg")
#+end_src

* Functionality and Packages
** Package management
:PROPERTIES:
:header-args:emacs-lisp: :tangle "packages.el" :noweb-ref none
:END:

Tangle the default instructions to packages.el. This is also where all the package declarations will be tangled to.
#+begin_src emacs-lisp
;; -*- no-byte-compile: t; -*-

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or


;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;; (package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/radian-software/straight.el#the-recipe-format
;; (package! another-package
;;   :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;; (package! this-package
;;   :recipe (:host github :repo "username/repo"
;;            :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;; (package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;; (package! builtin-package :recipe (:nonrecursive t))
;; (package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see radian-software/straight.el#279)
;; (package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
;; (package! builtin-package :pin "1a2b3c4d5e")


;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;; (unpin! pinned-package)
;; ...or multiple packages
;; (unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;; (unpin! t)
#+end_src

** Editor
#+call: confpkg()

*** Settings
Enable relative line numbers because it's a habit from vim
#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type 'relative)
#+END_SRC

*** Evil
**** evil
The ultimate convenience. We don't need to make any package declarations because we have the =:editor (evil +everywhere)= doom module enabled.

#+begin_src emacs-lisp
(after! evil
  (setq evil-want-fine-undo t)) ;; precise undo steps
#+end_src

**** evil-snipe
I don't want to spam j's and k's anymore
#+BEGIN_SRC emacs-lisp
(after! evil-snipe
  (setq evil-snipe-smart-case t
        evil-snipe-scope 'visible
        ))
#+END_SRC

**** evil-escape
I have no clue why this is enabled by default
#+begin_src emacs-lisp :tangle "packages.el"
(package! evil-escape :disable t)
#+end_src

**** Keybinds
General buffer navigation
#+BEGIN_SRC emacs-lisp
(map!  :m "H" #'evil-beginning-of-visual-line
       :m "L" #'evil-end-of-visual-line
       :m "0" #'evil-window-top
       :m "$" #'evil-window-bottom)
#+END_SRC

Make working with wrapped lines easy
#+BEGIN_SRC emacs-lisp
(map!  :nv "j" #'evil-next-visual-line
       :nv "k" #'evil-previous-visual-line)
#+END_SRC

*** Completion
** Organization
#+call: confpkg()

*** Workspace
Bind workspace navigation to be more like t-smart
#+BEGIN_SRC emacs-lisp
(map! :ni "C-t" #'+workspace/switch-to
      :ni [C-tab] #'+workspace/other)
#+END_SRC

*** Projects

** Org packages
#+call: confpkg("org-packages")

*** Org-Superstar
#+begin_src emacs-lisp :tangle "packages.el"
(package! org-superstar)
#+end_src

#+BEGIN_SRC emacs-lisp
(use-package! org-superstar
  :hook (org-mode-hook . (lambda () (org-superstar-mode 1)))
  :after org
  :config
  (setq org-superstar-leading-bullet " "
        org-superstar-headline-bullets-list '("●" "○" "◆" "◇" "•" "⚬")
        org-superstar-item-bullet-alist '((42 . "⚬") (43 . "⚬") (45 . "⚬"))
        org-superstar-prettify-item-bullets t)
  #+END_SRC

Plain-list bullets are invisible because they have the org-indent face. We can make them visible by having them inherit the default face.
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'org-list-dt nil :inherit 'default)
)
#+END_SRC
*** evil-tex
Provides useful text objects, movements, etc for LaTeX editing.
#+BEGIN_SRC emacs-lisp
(use-package! evil-tex
:hook (org-mode-hook . evil-tex-mode))
#+END_SRC

*** org-cdlatex
Org-cdlatex is the foundation to editing latex in org-mode. It removes much of the hassle of defining common latex macros and templates. Doing this with a snippet engine would've been pretty boring, so now we can just focus on adding more complex snippets like the auto-expanding ones to our snippet engine of choice: =aas=.

Change the symbol/modifier cycling key to ';'. Note for some reason these don't change the existing activating keymap bind; we do this later with =aas= though.
#+BEGIN_SRC emacs-lisp
(after! cdlatex
  (setq cdlatex-math-symbol-prefix ?\;)
  (setq cdlatex-math-modify-prefix ?\;)

  (map! :map org-cdlatex-mode-map
        "'" nil)
  (map! :map org-cdlatex-mode-map
        "`" nil)
#+END_SRC

Add custom environment snippets
#+BEGIN_SRC emacs-lisp
  (setq cdlatex-env-alist
        '(("bmatrix" "\\begin{bmatrix}\n?\n\\end{bmatrix}" nil)
          ("equation*" "\\begin{equation*}\n?\n\\end{equation*}" nil)))
#+END_SRC
Modify available symbols and modifiers
#+BEGIN_SRC emacs-lisp
   (setq cdlatex-math-symbol-alist
   '( ;; adding missing functions to 3rd level symbols
     (?_    ("\\downarrow"  ""           "\\inf"))
     (?2    ("^2"           "\\sqrt{?}"     ""     ))
     (?3    ("^3"           "\\sqrt[3]{?}"  ""     ))
     (?^    ("\\uparrow"    ""           "\\sup"))
     (?k    ("\\kappa"      ""           "\\ker"))
     (?m    ("\\mu"         ""           "\\lim"))
     (?c    (""             "\\circ"     "\\cos"))
     (?d    ("\\delta"      "\\partial"  "\\dim"))
     (?D    ("\\Delta"      "\\nabla"    "\\deg"))
     ;; no idea why \Phi isnt on 'F' in first place, \phi is on 'f'.
     (?F    ("\\Phi"))
     ;; now just convenience
     (?.    ("\\cdot " "\\dots "))
     (?:    ("\\vdots " "\\ddots "))
     (?*    ("\\cdot " "\\times " "\\star ")))

   cdlatex-math-modify-alist
   '( ;; adding modifiers
     (?B    "\\mathbb"        nil          t    nil  nil)
     (?a    "\\abs"           nil          t    nil  nil))))
#+END_SRC

**** Keybind hacks
I wanted to replace =indent-for-tab-command= with =cdlatex-tab= in the cdlatex contexts which is usually everywhere in an org file outside of snippets and source blocks. You'll often run through your snippets but still have to navigate the math, this is where having =cdlatex-tab= always available becomes massively useful.

#+begin_src emacs-lisp
(defun my/org-cdlatex-tab ()
  (interactive)
  (cond
   ;; Inside a snippet → yasnippet takes priority
   ((and (bound-and-true-p yas-minor-mode)
         (yas-active-snippets))
    (yas-next-field-or-maybe-expand))

   ;; Inside a source block → use default tab behavior
   ((org-in-src-block-p)
    (indent-for-tab-command))

   ;; Else → use cdlatex
   (t
    (cdlatex-tab))))
#+end_src

Add the binding to insert-state with cdlatex minor mode map for decent precedence. Note you can still use TAB's default behavior(indent-for-tab-command) by hitting "C-i" if you need to.
#+BEGIN_SRC emacs-lisp
(map! :map org-cdlatex-mode-map
      :i "<tab>" #'my/org-cdlatex-tab)
#+END_SRC

Rebind conflicting corfu's =[tab]= binding to =[M-tab]=. I don't use it much because the completion popup usually opens automatically.
#+BEGIN_SRC emacs-lisp
(map! :map corfu-map
      :i [tab] nil
      :i [m-tab] #'completion-at-point)
#+END_SRC

*** org-pdftools
This package comes in handy for custom org link types, but pdf links weren't working because the package makes depracated calls. A minor patch was made and here I've updated where the package is fetched from to my fork.
#+begin_src emacs-lisp :tangle "packages.el"
;; (package! org-pdftools
;;   :recipe (:host github
;;            :repo "ekattsim/org-pdftools"
;;            :branch "update-depracated-cl_calls"))

(package! org-pdftools
  :recipe (:fork (:repo "ekattsim/org-pdftools"
                  :branch "update-depracated-cl_calls")))

(unpin! org-pdftools)
#+end_src

*** Roam
Installed and pre-configured as part of the =:lang org +roam2= doom module.

Make "~/org/zettelkasten" the org-roam directory. Make sure only roam nodes are present in this directory.
#+BEGIN_SRC emacs-lisp
(setq org-roam-directory "~/org/zettelkasten")
#+END_SRC

** Snippets
#+call: confpkg()

*** smartparens
I just want to disable a couple default pairs in latex math mode. This is because idk yet.
#+begin_src emacs-lisp
(sp-pair "(" ")" :unless '(sp-in-math-p))
(sp-pair "[" nil :unless '(sp-in-math-p))
(sp-pair "{" nil :unless '(sp-in-math-p))
#+end_src

*** laas
#+call: confpkg("org-laas")

=laas= is a set of LaTeX snippets built on =aas= that are designed to work efficiently with existing tools like =cdlatex=.

#+begin_src emacs-lisp :tangle "packages.el"
(package! laas)
#+end_src

I don't really make any proper latex documents, so I'm limiting my snippets to just org mode.

#+BEGIN_SRC emacs-lisp
(use-package! laas
  :hook (org-mode-hook . laas-mode)
  :config
  (aas-set-snippets 'laas-mode
#+END_SRC

**** org snippets

Useful snippets while working with the org files in general.

#+BEGIN_SRC emacs-lisp
"<src" '(yas "#+begin_src ${1:$$(yas-completing-read \"Language: \" (mapcar #'car org-babel-load-languages))}\n$0\n#+end_src")
#+END_SRC

**** latex environments

Environments auto-expanding snippets are under the ";e" prefix. Note that these involve only the commonly used envs, for anything else use =org-cdlatex-environment-indent=.

#+BEGIN_SRC emacs-lisp
";e" nil

";ee" '(yas "\\begin{$1}\n $0 \n\\end{$1}") ;; arbitrary environment
";ea" (lambda () (interactive) (insert "ali*") (cdlatex-tab)) ;; align*
";eq" (lambda () (interactive) (insert "equ") (cdlatex-tab)) ;; equation

;; TODO figure out how to get "M-RET" behavior for items
";ei" (lambda () (interactive) (insert "ite") (cdlatex-tab)) ;; itemize
";en" (lambda () (interactive) (insert "enu") (cdlatex-tab)) ;; enumerate

";es" (lambda () (interactive) (insert "sn") (cdlatex-tab)) ;; section
"sb" (lambda () (interactive) (insert "ss") (cdlatex-tab)) ;; subsection
"ssb" (lambda () (interactive) (insert "sss") (cdlatex-tab)) ;; subsubsection
 #+END_SRC

**** latex symbols

 Symbol expansions are handled by =cdlatex-math-symbol=, here we just set the prefix using laas.

 #+BEGIN_SRC emacs-lisp
";s" (lambda () (interactive) (cdlatex-math-symbol)) ;; symbols prefix
 #+END_SRC

**** latex entry

 Snippets to enter latex math mode. We start using yasnippet from now on because of the increased complexity, laas internall calls =yas-expand-snippet.=

 #+BEGIN_SRC emacs-lisp
;; (copied from karthink). We double escape '\' if we're preceding escapable chars
"mk" '(yas "\\\\( $1 \\\\)$0 ") ;; We're trying to pass the string "\\( $1 \\)$0"
"dm" '(yas "\\[ $1 \\]$0")
 #+END_SRC

**** latex commands

 Here we create math-only autosnippets for commonly used latex commands. We don't lump them all into a single prefix like we've been doing, intuitiveness takes precedence. Still I try to keep things under the ';' though.

 #+BEGIN_SRC emacs-lisp
:cond #'texmathp

;; general commands prefix
";c" nil
";ce" '(yas "\\left. $1 \\right|_{$2}$0")

;; calculus stuff
"lm" '(yas "\\\\lim_{${1:x} \\\\to ${2:\\\\infty}}$0")
"sm" '(yas "\\sum_{${1:i}={$2:0}}^{${3:N}}$0")


;; integrals
";i" nil
";id" '(yas "\\\\int_{${1:-\\\\infty}}^{${2:\\\\infty}} $0")
";in" '(yas "\\\\int $1${2:dx}$0")
";2in" '(yas "\\\\iint $1${2:dA}$0")
";3in" '(yas "\\\\iiint $1${2:dV}$0")

;; derivatives
";d" nil
";di" '(yas "\\\\frac{\\\\mathrm{d}$1}{\\\\mathrm{d}${2:t}}$0")
";do" '(yas "\\\\frac{\\\\partial$1}{\\\\partial${2:t}}$0")
#+END_SRC

**** latex modifiers

Like symbols, most of them are implemented by =cdlatex=, we just make them more accessible by changing the prefix. Also note that =laas= also provides a few useful modifiers like the fraction and subscript handling which is sprinkled around.

#+BEGIN_SRC emacs-lisp
;; modifiers
";m" (lambda () (interactive) (org-cdlatex-math-modify)) ;; modifiers prefix

";t" (lambda () (interactive)
       (let ((last-command-event ?^)
             (last-command nil))
         (org-cdlatex-underscore-caret)))

";v" '(yas "\\vec{$1}$0")
";q" '(yas "\\sqrt{$1}$0")

;; I've disabled smartparens in latex math mode
"(" '(yas "($1)$0")
"[" '(yas "[$1]$0")
";{" '(yas "\\\\{$1\\\\}$0")

";(" '(yas "\\left( $0 \\right)")
";[" '(yas "\\left[ $0 \\right]")
";|" '(yas "\\left| $0 \\right|")
#+END_SRC

**** misc

#+begin_src emacs-lisp
;;"[M-RET]" '(yas "\\\\\n &=$0")
))
#+end_src

* Language configuration
** Org
#+call: confpkg()

*** Installation
This declaration is from org-latex-preview

#+begin_src emacs-lisp :tangle "packages.el"
(package! org :recipe
  (:host nil :repo "https://git.tecosaur.net/mirrors/org-mode.git" :remote "mirror" :fork
         (:host nil :repo "https://git.tecosaur.net/tec/org-mode.git" :branch "dev" :remote "tecosaur")
         :files
         (:defaults "etc")
         :build t :pre-build
         (with-temp-file "org-version.el"
           (require 'lisp-mnt)
           (let
               ((version
                 (with-temp-buffer
                   (insert-file-contents "lisp/org.el")
                   (lm-header "version")))
                (git-version
                 (string-trim
                  (with-temp-buffer
                    (call-process "git" nil t nil "rev-parse" "--short" "HEAD")
                    (buffer-string)))))
             (insert
              (format "(defun org-release () \"The release version of Org.\" %S)\n" version)
              (format "(defun org-git-version () \"The truncate git commit hash of Org mode.\" %S)\n" git-version)
              "(provide 'org-version)\n"))))
  :pin nil)

(unpin! org)
#+end_src

*** Settings

Central directory for org relative paths to resolve from. This will also house both our project and zettelkasten directories.
#+begin_src emacs-lisp
(setq org-directory "~/org")
#+end_src

*** Aesthetics
#+call: confpkg(name="org-aesthetics", after="org")

**** Fonts
Set Roboto Mono as header font and resize headings.
#+BEGIN_SRC emacs-lisp
;; Resize Org headings
(dolist (face '((org-level-1 . 1.35)
                (org-level-2 . 1.3)
                (org-level-3 . 1.2)
                (org-level-4 . 1.1)
                (org-level-5 . 1.1)
                (org-level-6 . 1.1)
                (org-level-7 . 1.1)
                (org-level-8 . 1.1)))
  (set-face-attribute (car face) nil :family "Roboto Mono" :weight 'bold :height (cdr face)))

;; Make the document title a bit bigger
(set-face-attribute 'org-document-title nil :family "Roboto Mono" :weight 'bold :height 1.8)
#+END_SRC

**** Decluttering
Don't be a litterbug!
#+BEGIN_SRC emacs-lisp
(setq org-adapt-indentation t
      org-hide-leading-stars t
      org-hide-emphasis-markers t)  ;; hide markers(bold, italics, etc)
      ;; messes with cursor positions in cdlatex templates
      ;; org-pretty-entities t) ;; allow LaTeX-like syntax to insert special symbols
#+END_SRC

**** Source Blocks
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-edit-src-content-indentation 0)
#+END_SRC

*** Latex Previews
**** Load/Enable
Configure org-latex-preview to be load after org and enable auto-mode which reveals source text under the fragment being pointed to.
#+BEGIN_SRC emacs-lisp
(use-package! org-latex-preview
:after org
:hook (org-mode-hook . org-latex-preview-auto-mode)
#+END_SRC

**** Appearance Settings
Basic appearance settings.
#+BEGIN_SRC emacs-lisp
:config
;; enable latex-previews startup option
(setq org-startup-with-latex-preview t)

;; Increase preview width
(plist-put org-latex-preview-appearance-options
:page-width 1.0)
(plist-put org-latex-preview-appearance-options
:zoom 1.2)

;; enable consistent equation numbering
(setq org-latex-preview-numbered t)
#+END_SRC

**** Latency and Performance
#+BEGIN_SRC emacs-lisp
;; real time previews of latex fagments as you type
(setq org-latex-preview-live t)
(setq org-latex-preview-live-debounce 0.25)  ;; reducing delay before preview

;; png is faster than svg
(setq org-latex-preview-process-default 'dvipng)
)
#+END_SRC

*** Links
+Try to open arbitrary files in emacs+. Not needed anymore since org-link type =file+emacs= exists.
#+begin_src emacs-lisp
;; (add-to-list 'org-file-apps '(t . emacs))
#+end_src

Open web links in nyxt. I cannot set it to default on macOS because I haven't built the required .app package.
#+begin_src emacs-lisp
;; (setcdr (assoc "\\.x?html?\\'" org-file-apps) "")
#+end_src

* Applications
#+call: confpkg()

** RSS feeds
#+begin_src emacs-lisp
(use-package! elfeed
  :config
  (setq elfeed-feeds
      '("https://xkcd.com/rss.xml"
        "https://hnrss.org/frontpage"
        "https://old.reddit.com/r/slatestarcodex.rss"
        "https://old.reddit.com/r/hardware.rss"))
  )
#+end_src

** Agenda
#+call: confpkg(after="org-agenda")

Take a look at [[id:9edd2c6e-2950-4689-b2e8-3c283297cd71][A new way of organization]]. In this section we'll mostly focus on the projects.

*** Setup
Create a variable for the project directory. The zettelkasten directory is created as =org-roam-directory= in [[*Roam]].
#+begin_src emacs-lisp
(defvar org-project-directory (expand-file-name "projects" org-directory))
#+end_src

Hopefully these will be the only locations with TODO items.
 #+begin_src emacs-lisp
(setq org-agenda-files (list +org-capture-todo-file org-project-directory (expand-file-name "config.org" doom-user-dir)))
#+end_src

Make sure that all org headings with backlinks also have an ID property. This is useful because heading titles can change but ids don't usually.
#+begin_src emacs-lisp
(setq org-id-link-to-org-use-id t)
#+end_src

*** Utilities

I need a function that can refile org-heading at point to a new a file. I'll be using this on my existing todo headings to link them to their project files.
#+begin_src emacs-lisp
(defun my/org-heading-to-project-file ()
  "Cut the current Org heading and its subtree, and paste it into a new project file.
The project file name is derived from the heading title and saved in `org-project-directory`.
Prompts for overwrite if the target file already exists."
  (interactive)
  (unless (org-at-heading-p)
    (user-error "Not at an Org heading"))

  ;; generate project-file path from heading-title
  (let* ((heading-title (org-get-heading t t t t))
         (sanitized-title (replace-regexp-in-string "[/?<>\\:*|\"&]" "_" heading-title))
         (project-file (expand-file-name (concat sanitized-title ".org")
                                         (or org-project-directory org-directory))))

    ;; Ask to confirm overwrite if file exists
    (if (and (file-exists-p project-file)
             (not (y-or-n-p (format "File '%s' already exists. Overwrite?" (file-name-nondirectory project-file)))))
        (user-error "Operation cancelled.")
      (progn
        ;; cut subtree from current buffer
        (org-back-to-heading t)
        (org-cut-subtree)

        ;; paste subtree
        (find-file project-file)
        (yank)

        ;; promote subtree until top-level
        (goto-char (point-min))
        (while (> (org-outline-level) 1)
          (org-promote-subtree))

        ;; save project-file
        (save-buffer)
        (message "Org heading moved to '%s'" project-file))
      )))
#+end_src

Find a project file under =org-project-directory= and bind it.
#+begin_src emacs-lisp
(defun my/find-in-projects ()
  (interactive)
  (ido-find-file-in-dir (or org-project-directory org-directory)))

(map! :map doom-leader-notes-map
      "p" #'my/find-in-projects)
#+end_src

*** Archiving
Set archive location, most likely only used on project files.
#+begin_src emacs-lisp
(setq org-archive-location (concat org-project-directory "/archives/%s_archive::"))
#+end_src

*** Workflow and Agenda view
Let's define the fundamental action cycle.
#+begin_src emacs-lisp
(setq org-todo-keywords '((sequence "TODO(t)" "INBOX(I)" "NEXT(n)" "WAIT(w)" "IDEA(i)" "|" "DONE(d)" "KILL(k)")))

;; Customized view for the daily workflow. (Command: "C-c a n")
(setq org-agenda-custom-commands
  '(("n" "Agenday / NEXT / INBOX / WAIT / IDEA"
     ((agenda "" nil)
      (todo "INBOX" ((org-agenda-prefix-format '((todo . " %i %c: %-17?(org-entry-get nil \"CREATED\")")))))
      (todo "NEXT" nil)
      (todo "WAIT" nil)
      (todo "IDEA" nil))
     nil)))
#+end_src

Show the daily agenda by default. Also known as agenday, that's gonna catch on.
#+begin_src emacs-lisp
(setq org-agenda-span 'day
   org-agenda-start-on-weekday nil
   org-agenda-start-day nil)
#+end_src

Shorten deadline reminders to 2d by default. 2 weeks prior warnings is too much org-mode.
#+begin_src emacs-lisp
(setq org-deadline-warning-days 2)
#+end_src

In this workflow all TODOs have to be scheduled, so let's add an advice over the =org-todo= and =org-agenda-todo= functions.
#+begin_src emacs-lisp
(defadvice! schedule-after-todo (_arg)
  :after '(org-todo org-agenda-todo)
  (save-excursion
    (when (and (equal (org-get-todo-state) "TODO")
               (not (org-get-scheduled-time (point))))
      (org-schedule nil))))
#+end_src)

*** Capture TODOs
#+call: confpkg(name="org-capture", after=["org"])

The workflow in my mind is that you would capture random TODOs to an inbox which you could then refile later with org-agenda. The capture mechanism is already implemented by [[file:~/dotfiles/emacs/dot-config/emacs/modules/lang/org/config.el::'(("t" "Personal todo" entry][doom's org module]], but there are a few changes I want to make.

Let's change the location of the TODOs inbox to be in the org-directory.
#+begin_src emacs-lisp
(setq +org-capture-todo-file (expand-file-name "inbox.org" org-directory))
#+end_src

Now let's make some changes to the default templates like todo template's description and removing the notes template since that is handled by roam.
#+begin_src emacs-lisp
(setq org-capture-templates
      (cons '("t" "todo" entry (file+headline +org-capture-todo-file "Inbox")
              "* INBOX %?\n:PROPERTIES:\n:CREATED: %u\n:END:" :prepend t)
            (cddr org-capture-templates)))
#+end_src

*** add dependency support for WAIT items
Some WAIT items are blocked because they are waiting for other tasks to be done first. In practice this means that you have to manually keep track of these dependencies like figuring out which WAIT item to put into the NEXT pile after completing a dependency TODO item.

We can automate this by allowing WAIT items to store a dependency list of items. When all of the items in this list are DONE, the WAIT item automatically becomes a NEXT item making it available for us to work on it.

We could have a function that on a DONE hook checks if the DONE was a dependency. If it was then decrement the dependency count by one. Finally check if dependency count = 0, then change item's TODO keyword from WAIT item to NEXT.

#+begin_src emacs-lisp
(defun my/org-task-done-hook ()
  "When a task is marked DONE, check if it unblocks any WAIT tasks."
  (when (string= org-state "DONE")
    (let ((done-id (org-id-get)))
      (my/org-update-dependent-tasks done-id))))

(defun my/org-update-dependent-tasks (done-id)
  "Update all WAIT tasks that list DONE-ID as a dependency."
  (org-map-entries
   (lambda ()
     (let ((deps-str (org-entry-get (point) "Dependencies")))
       (when deps-str
         (let ((new-deps (remove-org-id-link-from-deps deps-str done-id)))
           (org-set-property "Dependencies" new-deps)
           (when (string-empty-p new-deps)
             (org-todo "NEXT"))))))
   "/+WAIT" 'agenda))

(defun remove-org-id-link-from-deps (deps-str done-id)
  "Remove the Org link with DONE-ID from DEPS-STR and trim excess whitespace."
  (string-trim
   (replace-regexp-in-string
    (format "\\[\\[id:%s\\]\\[.*?\\]\\][[:space:]]*" (regexp-quote done-id))
    ""
    deps-str)))

(add-hook 'org-after-todo-state-change-hook #'my/org-task-done-hook)
#+end_src
